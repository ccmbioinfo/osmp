/* tslint:disable */
/* eslint-disable */
/**
 * Slurm Rest API
 * API to access and control Slurm.
 *
 * The version of the OpenAPI document: 0.0.37
 * Contact: sales@schedmd.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Account description
 * @export
 * @interface Dbv0036Account
 */
export interface Dbv0036Account {
  /**
   * List of assigned associations
   * @type {Array<Dbv0036AssociationShortInfo>}
   * @memberof Dbv0036Account
   */
  associations?: Array<Dbv0036AssociationShortInfo>;
  /**
   * List of assigned coordinators
   * @type {Array<Dbv0036CoordinatorInfo>}
   * @memberof Dbv0036Account
   */
  coordinators?: Array<Dbv0036CoordinatorInfo>;
  /**
   * Description of account
   * @type {string}
   * @memberof Dbv0036Account
   */
  description?: string;
  /**
   * Name of account
   * @type {string}
   * @memberof Dbv0036Account
   */
  name?: string;
  /**
   * Assigned organization of account
   * @type {string}
   * @memberof Dbv0036Account
   */
  organization?: string;
  /**
   * List of properties of account
   * @type {Array<string>}
   * @memberof Dbv0036Account
   */
  flags?: Array<string>;
}
/**
 *
 * @export
 * @interface Dbv0036AccountInfo
 */
export interface Dbv0036AccountInfo {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036AccountInfo
   */
  errors?: Array<Dbv0036Error>;
  /**
   * List of accounts
   * @type {Array<Dbv0036Account>}
   * @memberof Dbv0036AccountInfo
   */
  accounts?: Array<Dbv0036Account>;
}
/**
 *
 * @export
 * @interface Dbv0036AccountResponse
 */
export interface Dbv0036AccountResponse {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036AccountResponse
   */
  errors?: Array<Dbv0036Error>;
}
/**
 * Association description
 * @export
 * @interface Dbv0036Association
 */
export interface Dbv0036Association {
  /**
   * Assigned account
   * @type {string}
   * @memberof Dbv0036Association
   */
  account?: string;
  /**
   * Assigned cluster
   * @type {string}
   * @memberof Dbv0036Association
   */
  cluster?: string;
  /**
   *
   * @type {Dbv0036AssociationDefault}
   * @memberof Dbv0036Association
   */
  default?: Dbv0036AssociationDefault;
  /**
   * List of properties of association
   * @type {Array<string>}
   * @memberof Dbv0036Association
   */
  flags?: Array<string>;
  /**
   *
   * @type {Dbv0036AssociationMax}
   * @memberof Dbv0036Association
   */
  max?: Dbv0036AssociationMax;
  /**
   *
   * @type {Dbv0036AssociationMin}
   * @memberof Dbv0036Association
   */
  min?: Dbv0036AssociationMin;
  /**
   * Parent account name
   * @type {string}
   * @memberof Dbv0036Association
   */
  parent_account?: string;
  /**
   * Assigned partition
   * @type {string}
   * @memberof Dbv0036Association
   */
  partition?: string;
  /**
   * Assigned priority
   * @type {number}
   * @memberof Dbv0036Association
   */
  priority?: number;
  /**
   * Assigned QOS
   * @type {Array<string>}
   * @memberof Dbv0036Association
   */
  qos?: Array<string>;
  /**
   * Raw fairshare shares
   * @type {number}
   * @memberof Dbv0036Association
   */
  shares_raw?: number;
  /**
   *
   * @type {Dbv0036AssociationUsage}
   * @memberof Dbv0036Association
   */
  usage?: Dbv0036AssociationUsage;
  /**
   * Assigned user
   * @type {string}
   * @memberof Dbv0036Association
   */
  user?: string;
}
/**
 * Default settings
 * @export
 * @interface Dbv0036AssociationDefault
 */
export interface Dbv0036AssociationDefault {
  /**
   * Default QOS
   * @type {string}
   * @memberof Dbv0036AssociationDefault
   */
  qos?: string;
}
/**
 * Max settings
 * @export
 * @interface Dbv0036AssociationMax
 */
export interface Dbv0036AssociationMax {
  /**
   *
   * @type {Dbv0036AssociationMaxJobs}
   * @memberof Dbv0036AssociationMax
   */
  jobs?: Dbv0036AssociationMaxJobs;
  /**
   *
   * @type {Dbv0036AssociationMaxPer}
   * @memberof Dbv0036AssociationMax
   */
  per?: Dbv0036AssociationMaxPer;
  /**
   *
   * @type {Dbv0036AssociationMaxTres}
   * @memberof Dbv0036AssociationMax
   */
  tres?: Dbv0036AssociationMaxTres;
}
/**
 * Max jobs settings
 * @export
 * @interface Dbv0036AssociationMaxJobs
 */
export interface Dbv0036AssociationMaxJobs {
  /**
   *
   * @type {Dbv0036AssociationMaxJobsPer}
   * @memberof Dbv0036AssociationMaxJobs
   */
  per?: Dbv0036AssociationMaxJobsPer;
}
/**
 * Max jobs per settings
 * @export
 * @interface Dbv0036AssociationMaxJobsPer
 */
export interface Dbv0036AssociationMaxJobsPer {
  /**
   * Max wallclock per job
   * @type {number}
   * @memberof Dbv0036AssociationMaxJobsPer
   */
  wall_clock?: number;
}
/**
 * Max per settings
 * @export
 * @interface Dbv0036AssociationMaxPer
 */
export interface Dbv0036AssociationMaxPer {
  /**
   *
   * @type {Dbv0036AssociationMaxPerAccount}
   * @memberof Dbv0036AssociationMaxPer
   */
  account?: Dbv0036AssociationMaxPerAccount;
}
/**
 * Max per accounting settings
 * @export
 * @interface Dbv0036AssociationMaxPerAccount
 */
export interface Dbv0036AssociationMaxPerAccount {
  /**
   * Max wallclock per account
   * @type {number}
   * @memberof Dbv0036AssociationMaxPerAccount
   */
  wall_clock?: number;
}
/**
 * Max TRES settings
 * @export
 * @interface Dbv0036AssociationMaxTres
 */
export interface Dbv0036AssociationMaxTres {
  /**
   *
   * @type {Dbv0036AssociationMaxTresPer}
   * @memberof Dbv0036AssociationMaxTres
   */
  per?: Dbv0036AssociationMaxTresPer;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036AssociationMaxTres
   */
  total?: Array<object>;
  /**
   *
   * @type {Dbv0036AssociationMaxTresMinutes}
   * @memberof Dbv0036AssociationMaxTres
   */
  minutes?: Dbv0036AssociationMaxTresMinutes;
}
/**
 * Max TRES minutes settings
 * @export
 * @interface Dbv0036AssociationMaxTresMinutes
 */
export interface Dbv0036AssociationMaxTresMinutes {
  /**
   *
   * @type {Dbv0036AssociationMaxTresMinutesPer}
   * @memberof Dbv0036AssociationMaxTresMinutes
   */
  per?: Dbv0036AssociationMaxTresMinutesPer;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036AssociationMaxTresMinutes
   */
  total?: Array<object>;
}
/**
 * Max TRES minutes per settings
 * @export
 * @interface Dbv0036AssociationMaxTresMinutesPer
 */
export interface Dbv0036AssociationMaxTresMinutesPer {
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036AssociationMaxTresMinutesPer
   */
  job?: Array<object>;
}
/**
 * Max TRES per settings
 * @export
 * @interface Dbv0036AssociationMaxTresPer
 */
export interface Dbv0036AssociationMaxTresPer {
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036AssociationMaxTresPer
   */
  job?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036AssociationMaxTresPer
   */
  node?: Array<object>;
}
/**
 * Min settings
 * @export
 * @interface Dbv0036AssociationMin
 */
export interface Dbv0036AssociationMin {
  /**
   * Min priority threshold
   * @type {number}
   * @memberof Dbv0036AssociationMin
   */
  priority_threshold?: number;
}
/**
 *
 * @export
 * @interface Dbv0036AssociationShortInfo
 */
export interface Dbv0036AssociationShortInfo {
  /**
   * Account name
   * @type {string}
   * @memberof Dbv0036AssociationShortInfo
   */
  account?: string;
  /**
   * Cluster name
   * @type {string}
   * @memberof Dbv0036AssociationShortInfo
   */
  cluster?: string;
  /**
   * Partition name (optional)
   * @type {string}
   * @memberof Dbv0036AssociationShortInfo
   */
  partition?: string;
  /**
   * User name
   * @type {string}
   * @memberof Dbv0036AssociationShortInfo
   */
  user?: string;
}
/**
 * Association usage
 * @export
 * @interface Dbv0036AssociationUsage
 */
export interface Dbv0036AssociationUsage {
  /**
   * Jobs accuring priority
   * @type {number}
   * @memberof Dbv0036AssociationUsage
   */
  accrue_job_count?: number;
  /**
   * Group used wallclock time (s)
   * @type {number}
   * @memberof Dbv0036AssociationUsage
   */
  group_used_wallclock?: number;
  /**
   * Fairshare factor
   * @type {number}
   * @memberof Dbv0036AssociationUsage
   */
  fairshare_factor?: number;
  /**
   * Fairshare shares
   * @type {number}
   * @memberof Dbv0036AssociationUsage
   */
  fairshare_shares?: number;
  /**
   * Currently active jobs
   * @type {number}
   * @memberof Dbv0036AssociationUsage
   */
  normalized_priority?: number;
  /**
   * Normalized shares
   * @type {number}
   * @memberof Dbv0036AssociationUsage
   */
  normalized_shares?: number;
  /**
   * Effective normalized usage
   * @type {number}
   * @memberof Dbv0036AssociationUsage
   */
  effective_normalized_usage?: number;
  /**
   * Raw usage
   * @type {number}
   * @memberof Dbv0036AssociationUsage
   */
  raw_usage?: number;
  /**
   * Total jobs submitted
   * @type {number}
   * @memberof Dbv0036AssociationUsage
   */
  job_count?: number;
  /**
   * Fairshare level
   * @type {number}
   * @memberof Dbv0036AssociationUsage
   */
  fairshare_level?: number;
}
/**
 *
 * @export
 * @interface Dbv0036AssociationsInfo
 */
export interface Dbv0036AssociationsInfo {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036AssociationsInfo
   */
  errors?: Array<Dbv0036Error>;
  /**
   * Array of associations
   * @type {Array<Dbv0036Association>}
   * @memberof Dbv0036AssociationsInfo
   */
  associations?: Array<Dbv0036Association>;
}
/**
 *
 * @export
 * @interface Dbv0036ClusterInfo
 */
export interface Dbv0036ClusterInfo {
  /**
   *
   * @type {Dbv0036ClusterInfoController}
   * @memberof Dbv0036ClusterInfo
   */
  controller?: Dbv0036ClusterInfoController;
  /**
   * List of properties of cluster
   * @type {Array<string>}
   * @memberof Dbv0036ClusterInfo
   */
  flags?: Array<string>;
  /**
   * Cluster name
   * @type {string}
   * @memberof Dbv0036ClusterInfo
   */
  name?: string;
  /**
   * Assigned nodes
   * @type {string}
   * @memberof Dbv0036ClusterInfo
   */
  nodes?: string;
  /**
   * Configured select plugin
   * @type {string}
   * @memberof Dbv0036ClusterInfo
   */
  select_plugin?: string;
  /**
   *
   * @type {Dbv0036ClusterInfoAssociations}
   * @memberof Dbv0036ClusterInfo
   */
  associations?: Dbv0036ClusterInfoAssociations;
  /**
   * Number rpc version
   * @type {number}
   * @memberof Dbv0036ClusterInfo
   */
  rpc_version?: number;
  /**
   * List of TRES in cluster
   * @type {Array<Dbv0036ResponseTres>}
   * @memberof Dbv0036ClusterInfo
   */
  tres?: Array<Dbv0036ResponseTres>;
}
/**
 * Information about associations
 * @export
 * @interface Dbv0036ClusterInfoAssociations
 */
export interface Dbv0036ClusterInfoAssociations {
  /**
   *
   * @type {Dbv0036AssociationShortInfo}
   * @memberof Dbv0036ClusterInfoAssociations
   */
  root?: Dbv0036AssociationShortInfo;
}
/**
 * Information about controller
 * @export
 * @interface Dbv0036ClusterInfoController
 */
export interface Dbv0036ClusterInfoController {
  /**
   * Hostname
   * @type {string}
   * @memberof Dbv0036ClusterInfoController
   */
  host?: string;
  /**
   * Port number
   * @type {number}
   * @memberof Dbv0036ClusterInfoController
   */
  port?: number;
}
/**
 *
 * @export
 * @interface Dbv0036ConfigInfo
 */
export interface Dbv0036ConfigInfo {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036ConfigInfo
   */
  errors?: Array<Dbv0036Error>;
  /**
   * Array of TRES
   * @type {Array<Array<object>>}
   * @memberof Dbv0036ConfigInfo
   */
  tres?: Array<Array<object>>;
  /**
   * Array of accounts
   * @type {Array<Dbv0036Account>}
   * @memberof Dbv0036ConfigInfo
   */
  accounts?: Array<Dbv0036Account>;
  /**
   * Array of associations
   * @type {Array<Dbv0036Association>}
   * @memberof Dbv0036ConfigInfo
   */
  associations?: Array<Dbv0036Association>;
  /**
   * Array of users
   * @type {Array<Dbv0036User>}
   * @memberof Dbv0036ConfigInfo
   */
  users?: Array<Dbv0036User>;
  /**
   * Array of qos
   * @type {Array<Dbv0036Qos>}
   * @memberof Dbv0036ConfigInfo
   */
  qos?: Array<Dbv0036Qos>;
  /**
   * Array of wckeys
   * @type {Array<Dbv0036Wckey>}
   * @memberof Dbv0036ConfigInfo
   */
  wckeys?: Array<Dbv0036Wckey>;
}
/**
 *
 * @export
 * @interface Dbv0036ConfigResponse
 */
export interface Dbv0036ConfigResponse {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036ConfigResponse
   */
  errors?: Array<Dbv0036Error>;
}
/**
 *
 * @export
 * @interface Dbv0036CoordinatorInfo
 */
export interface Dbv0036CoordinatorInfo {
  /**
   * Name of user
   * @type {string}
   * @memberof Dbv0036CoordinatorInfo
   */
  name?: string;
  /**
   * If user is coordinator of this account directly or coordinator status was inheirted from a higher account in the tree
   * @type {number}
   * @memberof Dbv0036CoordinatorInfo
   */
  direct?: number;
}
/**
 *
 * @export
 * @interface Dbv0036Diag
 */
export interface Dbv0036Diag {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036Diag
   */
  errors?: Array<Dbv0036Error>;
  /**
   * Unix timestamp of start time
   * @type {number}
   * @memberof Dbv0036Diag
   */
  time_start?: number;
  /**
   *
   * @type {Array<Dbv0036DiagRollups>}
   * @memberof Dbv0036Diag
   */
  rollups?: Array<Dbv0036DiagRollups>;
  /**
   *
   * @type {Array<Dbv0036DiagRPCs>}
   * @memberof Dbv0036Diag
   */
  RPCs?: Array<Dbv0036DiagRPCs>;
  /**
   *
   * @type {Array<Dbv0036DiagUsers>}
   * @memberof Dbv0036Diag
   */
  users?: Array<Dbv0036DiagUsers>;
}
/**
 * Statistics by RPC type
 * @export
 * @interface Dbv0036DiagRPCs
 */
export interface Dbv0036DiagRPCs {
  /**
   * RPC type
   * @type {string}
   * @memberof Dbv0036DiagRPCs
   */
  rpc?: string;
  /**
   * Number of RPCs
   * @type {number}
   * @memberof Dbv0036DiagRPCs
   */
  count?: number;
  /**
   *
   * @type {Dbv0036DiagTime}
   * @memberof Dbv0036DiagRPCs
   */
  time?: Dbv0036DiagTime;
}
/**
 * Rollup statistics
 * @export
 * @interface Dbv0036DiagRollups
 */
export interface Dbv0036DiagRollups {
  /**
   * Type of rollup
   * @type {string}
   * @memberof Dbv0036DiagRollups
   */
  type?: string;
  /**
   * Timestamp of last rollup
   * @type {number}
   * @memberof Dbv0036DiagRollups
   */
  last_run?: number;
  /**
   * Timestamp of last cycle
   * @type {number}
   * @memberof Dbv0036DiagRollups
   */
  last_cycle?: number;
  /**
   * Max time of all cycles
   * @type {number}
   * @memberof Dbv0036DiagRollups
   */
  max_cycle?: number;
  /**
   * Total time (s) spent doing rollup
   * @type {number}
   * @memberof Dbv0036DiagRollups
   */
  total_time?: number;
  /**
   * Average time (s) of cycle
   * @type {number}
   * @memberof Dbv0036DiagRollups
   */
  mean_cycles?: number;
}
/**
 * Time values
 * @export
 * @interface Dbv0036DiagTime
 */
export interface Dbv0036DiagTime {
  /**
   * Average time spent processing this RPC type
   * @type {number}
   * @memberof Dbv0036DiagTime
   */
  average?: number;
  /**
   * Total time spent processing this RPC type
   * @type {number}
   * @memberof Dbv0036DiagTime
   */
  total?: number;
}
/**
 * Time values
 * @export
 * @interface Dbv0036DiagTime1
 */
export interface Dbv0036DiagTime1 {
  /**
   * Average time spent processing each user RPC
   * @type {number}
   * @memberof Dbv0036DiagTime1
   */
  average?: number;
  /**
   * Total time spent processing each user RPC
   * @type {number}
   * @memberof Dbv0036DiagTime1
   */
  total?: number;
}
/**
 * Statistics by user RPCs
 * @export
 * @interface Dbv0036DiagUsers
 */
export interface Dbv0036DiagUsers {
  /**
   * User name
   * @type {string}
   * @memberof Dbv0036DiagUsers
   */
  user?: string;
  /**
   * Number of RPCs
   * @type {number}
   * @memberof Dbv0036DiagUsers
   */
  count?: number;
  /**
   *
   * @type {Dbv0036DiagTime1}
   * @memberof Dbv0036DiagUsers
   */
  time?: Dbv0036DiagTime1;
}
/**
 *
 * @export
 * @interface Dbv0036Error
 */
export interface Dbv0036Error {
  /**
   * Error number
   * @type {number}
   * @memberof Dbv0036Error
   */
  errno?: number;
  /**
   * Error message
   * @type {string}
   * @memberof Dbv0036Error
   */
  error?: string;
}
/**
 * Single job description
 * @export
 * @interface Dbv0036Job
 */
export interface Dbv0036Job {
  /**
   * Account charged by job
   * @type {string}
   * @memberof Dbv0036Job
   */
  account?: string;
  /**
   *
   * @type {Dbv0036JobComment}
   * @memberof Dbv0036Job
   */
  comment?: Dbv0036JobComment;
  /**
   * Nodes allocated to job
   * @type {string}
   * @memberof Dbv0036Job
   */
  allocation_nodes?: string;
  /**
   *
   * @type {Dbv0036JobArray}
   * @memberof Dbv0036Job
   */
  array?: Dbv0036JobArray;
  /**
   *
   * @type {Dbv0036JobTime}
   * @memberof Dbv0036Job
   */
  time?: Dbv0036JobTime;
  /**
   *
   * @type {Dbv0036AssociationShortInfo}
   * @memberof Dbv0036Job
   */
  association?: Dbv0036AssociationShortInfo;
  /**
   * Assigned cluster
   * @type {string}
   * @memberof Dbv0036Job
   */
  cluster?: string;
  /**
   * Constraints on job
   * @type {string}
   * @memberof Dbv0036Job
   */
  constraints?: string;
  /**
   *
   * @type {Dbv0036JobExitCode}
   * @memberof Dbv0036Job
   */
  derived_exit_code?: Dbv0036JobExitCode;
  /**
   *
   * @type {Dbv0036JobExitCode}
   * @memberof Dbv0036Job
   */
  exit_code?: Dbv0036JobExitCode;
  /**
   * List of properties of job
   * @type {Array<string>}
   * @memberof Dbv0036Job
   */
  flags?: Array<string>;
  /**
   * User\'s group to run job
   * @type {string}
   * @memberof Dbv0036Job
   */
  group?: string;
  /**
   *
   * @type {Dbv0036JobHet}
   * @memberof Dbv0036Job
   */
  het?: Dbv0036JobHet;
  /**
   * Job id
   * @type {number}
   * @memberof Dbv0036Job
   */
  job_id?: number;
  /**
   * Assigned job name
   * @type {string}
   * @memberof Dbv0036Job
   */
  name?: string;
  /**
   *
   * @type {Dbv0036JobMcs}
   * @memberof Dbv0036Job
   */
  mcs?: Dbv0036JobMcs;
  /**
   * List of nodes allocated for job
   * @type {string}
   * @memberof Dbv0036Job
   */
  nodes?: string;
  /**
   * Assigned job\'s partition
   * @type {string}
   * @memberof Dbv0036Job
   */
  partition?: string;
  /**
   * Priority
   * @type {number}
   * @memberof Dbv0036Job
   */
  priority?: number;
  /**
   * Assigned qos name
   * @type {string}
   * @memberof Dbv0036Job
   */
  qos?: string;
  /**
   *
   * @type {Dbv0036JobRequired}
   * @memberof Dbv0036Job
   */
  required?: Dbv0036JobRequired;
  /**
   * User who requested job killed
   * @type {string}
   * @memberof Dbv0036Job
   */
  kill_request_user?: string;
  /**
   *
   * @type {Dbv0036JobReservation}
   * @memberof Dbv0036Job
   */
  reservation?: Dbv0036JobReservation;
  /**
   *
   * @type {Dbv0036JobState}
   * @memberof Dbv0036Job
   */
  state?: Dbv0036JobState;
  /**
   * Job step description
   * @type {Array<Dbv0036JobStep>}
   * @memberof Dbv0036Job
   */
  steps?: Array<Dbv0036JobStep>;
  /**
   *
   * @type {Dbv0036JobTres}
   * @memberof Dbv0036Job
   */
  tres?: Dbv0036JobTres;
  /**
   * Job user
   * @type {string}
   * @memberof Dbv0036Job
   */
  user?: string;
  /**
   *
   * @type {Dbv0036JobWckey}
   * @memberof Dbv0036Job
   */
  wckey?: Dbv0036JobWckey;
  /**
   * Directory where job was initially started
   * @type {string}
   * @memberof Dbv0036Job
   */
  working_directory?: string;
}
/**
 * Array properties (optional)
 * @export
 * @interface Dbv0036JobArray
 */
export interface Dbv0036JobArray {
  /**
   * Job id of array
   * @type {number}
   * @memberof Dbv0036JobArray
   */
  job_id?: number;
  /**
   *
   * @type {Dbv0036JobArrayLimits}
   * @memberof Dbv0036JobArray
   */
  limits?: Dbv0036JobArrayLimits;
  /**
   * Array task
   * @type {string}
   * @memberof Dbv0036JobArray
   */
  task?: string;
  /**
   * Array task id
   * @type {number}
   * @memberof Dbv0036JobArray
   */
  task_id?: number;
}
/**
 * Limits on array settings
 * @export
 * @interface Dbv0036JobArrayLimits
 */
export interface Dbv0036JobArrayLimits {
  /**
   *
   * @type {Dbv0036JobArrayLimitsMax}
   * @memberof Dbv0036JobArrayLimits
   */
  max?: Dbv0036JobArrayLimitsMax;
}
/**
 * Limits on array settings
 * @export
 * @interface Dbv0036JobArrayLimitsMax
 */
export interface Dbv0036JobArrayLimitsMax {
  /**
   *
   * @type {Dbv0036JobArrayLimitsMaxRunning}
   * @memberof Dbv0036JobArrayLimitsMax
   */
  running?: Dbv0036JobArrayLimitsMaxRunning;
}
/**
 * Limits on array settings
 * @export
 * @interface Dbv0036JobArrayLimitsMaxRunning
 */
export interface Dbv0036JobArrayLimitsMaxRunning {
  /**
   * Max running tasks in array at any one time
   * @type {number}
   * @memberof Dbv0036JobArrayLimitsMaxRunning
   */
  tasks?: number;
}
/**
 * Job comments by type
 * @export
 * @interface Dbv0036JobComment
 */
export interface Dbv0036JobComment {
  /**
   * Administrator set comment
   * @type {string}
   * @memberof Dbv0036JobComment
   */
  administrator?: string;
  /**
   * Job comment
   * @type {string}
   * @memberof Dbv0036JobComment
   */
  job?: string;
  /**
   * System set comment
   * @type {string}
   * @memberof Dbv0036JobComment
   */
  system?: string;
}
/**
 *
 * @export
 * @interface Dbv0036JobExitCode
 */
export interface Dbv0036JobExitCode {
  /**
   * Job exit status
   * @type {string}
   * @memberof Dbv0036JobExitCode
   */
  status?: string;
  /**
   * Return code from parent process
   * @type {number}
   * @memberof Dbv0036JobExitCode
   */
  return_code?: number;
  /**
   *
   * @type {Dbv0036JobExitCodeSignal}
   * @memberof Dbv0036JobExitCode
   */
  signal?: Dbv0036JobExitCodeSignal;
}
/**
 * Signal details (if signaled)
 * @export
 * @interface Dbv0036JobExitCodeSignal
 */
export interface Dbv0036JobExitCodeSignal {
  /**
   * Signal number process received
   * @type {number}
   * @memberof Dbv0036JobExitCodeSignal
   */
  signal_id?: number;
  /**
   * Name of signal received
   * @type {string}
   * @memberof Dbv0036JobExitCodeSignal
   */
  name?: string;
}
/**
 * Heterogeneous Job details (optional)
 * @export
 * @interface Dbv0036JobHet
 */
export interface Dbv0036JobHet {
  /**
   * Parent HetJob id
   * @type {object}
   * @memberof Dbv0036JobHet
   */
  job_id?: object;
  /**
   * Offset of this job to parent
   * @type {object}
   * @memberof Dbv0036JobHet
   */
  job_offset?: object;
}
/**
 *
 * @export
 * @interface Dbv0036JobInfo
 */
export interface Dbv0036JobInfo {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036JobInfo
   */
  errors?: Array<Dbv0036Error>;
  /**
   * Array of jobs
   * @type {Array<Dbv0036Job>}
   * @memberof Dbv0036JobInfo
   */
  jobs?: Array<Dbv0036Job>;
}
/**
 * Multi-Category Security
 * @export
 * @interface Dbv0036JobMcs
 */
export interface Dbv0036JobMcs {
  /**
   * Assigned MCS label
   * @type {string}
   * @memberof Dbv0036JobMcs
   */
  label?: string;
}
/**
 * Job run requirements
 * @export
 * @interface Dbv0036JobRequired
 */
export interface Dbv0036JobRequired {
  /**
   * Required number of CPUs
   * @type {number}
   * @memberof Dbv0036JobRequired
   */
  CPUs?: number;
  /**
   * Required amount of memory (MiB)
   * @type {number}
   * @memberof Dbv0036JobRequired
   */
  memory?: number;
}
/**
 * Reservation usage details
 * @export
 * @interface Dbv0036JobReservation
 */
export interface Dbv0036JobReservation {
  /**
   * Database id of reservation
   * @type {number}
   * @memberof Dbv0036JobReservation
   */
  id?: number;
  /**
   * Name of reservation
   * @type {number}
   * @memberof Dbv0036JobReservation
   */
  name?: number;
}
/**
 * State properties of job
 * @export
 * @interface Dbv0036JobState
 */
export interface Dbv0036JobState {
  /**
   * Current state of job
   * @type {string}
   * @memberof Dbv0036JobState
   */
  current?: string;
  /**
   * Last reason job didn\'t run
   * @type {string}
   * @memberof Dbv0036JobState
   */
  previous?: string;
}
/**
 *
 * @export
 * @interface Dbv0036JobStep
 */
export interface Dbv0036JobStep {
  /**
   *
   * @type {Dbv0036JobStepTime}
   * @memberof Dbv0036JobStep
   */
  time?: Dbv0036JobStepTime;
  /**
   *
   * @type {Dbv0036JobExitCode}
   * @memberof Dbv0036JobStep
   */
  exit_code?: Dbv0036JobExitCode;
  /**
   *
   * @type {Dbv0036JobStepNodes}
   * @memberof Dbv0036JobStep
   */
  nodes?: Dbv0036JobStepNodes;
  /**
   *
   * @type {Dbv0036JobStepTasks}
   * @memberof Dbv0036JobStep
   */
  tasks?: Dbv0036JobStepTasks;
  /**
   * First process PID
   * @type {string}
   * @memberof Dbv0036JobStep
   */
  pid?: string;
  /**
   *
   * @type {Dbv0036JobStepCPU}
   * @memberof Dbv0036JobStep
   */
  CPU?: Dbv0036JobStepCPU;
  /**
   * User who requested job killed
   * @type {string}
   * @memberof Dbv0036JobStep
   */
  kill_request_user?: string;
  /**
   * State of job step
   * @type {string}
   * @memberof Dbv0036JobStep
   */
  state?: string;
  /**
   *
   * @type {Dbv0036JobStepStatistics}
   * @memberof Dbv0036JobStep
   */
  statistics?: Dbv0036JobStepStatistics;
  /**
   *
   * @type {Dbv0036JobStepStep}
   * @memberof Dbv0036JobStep
   */
  step?: Dbv0036JobStepStep;
}
/**
 * CPU properties
 * @export
 * @interface Dbv0036JobStepCPU
 */
export interface Dbv0036JobStepCPU {
  /**
   *
   * @type {Dbv0036JobStepCPURequestedFrequency}
   * @memberof Dbv0036JobStepCPU
   */
  requested_frequency?: Dbv0036JobStepCPURequestedFrequency;
  /**
   * CPU governor
   * @type {Array<string>}
   * @memberof Dbv0036JobStepCPU
   */
  governor?: Array<string>;
}
/**
 * CPU frequency requested
 * @export
 * @interface Dbv0036JobStepCPURequestedFrequency
 */
export interface Dbv0036JobStepCPURequestedFrequency {
  /**
   * Min CPU frequency
   * @type {number}
   * @memberof Dbv0036JobStepCPURequestedFrequency
   */
  min?: number;
  /**
   * Max CPU frequency
   * @type {number}
   * @memberof Dbv0036JobStepCPURequestedFrequency
   */
  max?: number;
}
/**
 * Node details
 * @export
 * @interface Dbv0036JobStepNodes
 */
export interface Dbv0036JobStepNodes {
  /**
   * Total number of nodes in step
   * @type {number}
   * @memberof Dbv0036JobStepNodes
   */
  count?: number;
  /**
   * Nodes in step
   * @type {string}
   * @memberof Dbv0036JobStepNodes
   */
  range?: string;
}
/**
 * Statistics of job step
 * @export
 * @interface Dbv0036JobStepStatistics
 */
export interface Dbv0036JobStepStatistics {
  /**
   *
   * @type {Dbv0036JobStepStatisticsCPU}
   * @memberof Dbv0036JobStepStatistics
   */
  CPU?: Dbv0036JobStepStatisticsCPU;
  /**
   *
   * @type {Dbv0036JobStepStatisticsEnergy}
   * @memberof Dbv0036JobStepStatistics
   */
  energy?: Dbv0036JobStepStatisticsEnergy;
}
/**
 * Statistics of CPU
 * @export
 * @interface Dbv0036JobStepStatisticsCPU
 */
export interface Dbv0036JobStepStatisticsCPU {
  /**
   * Actual frequency of CPU during step
   * @type {number}
   * @memberof Dbv0036JobStepStatisticsCPU
   */
  actual_frequency?: number;
}
/**
 * Statistics of energy
 * @export
 * @interface Dbv0036JobStepStatisticsEnergy
 */
export interface Dbv0036JobStepStatisticsEnergy {
  /**
   * Energy consumed during step
   * @type {number}
   * @memberof Dbv0036JobStepStatisticsEnergy
   */
  consumed?: number;
}
/**
 * Step details
 * @export
 * @interface Dbv0036JobStepStep
 */
export interface Dbv0036JobStepStep {
  /**
   * Parent job id
   * @type {number}
   * @memberof Dbv0036JobStepStep
   */
  job_id?: number;
  /**
   *
   * @type {Dbv0036JobStepStepHet}
   * @memberof Dbv0036JobStepStep
   */
  het?: Dbv0036JobStepStepHet;
  /**
   * Step id
   * @type {string}
   * @memberof Dbv0036JobStepStep
   */
  id?: string;
  /**
   * Step name
   * @type {string}
   * @memberof Dbv0036JobStepStep
   */
  name?: string;
  /**
   *
   * @type {Dbv0036JobStepStepTask}
   * @memberof Dbv0036JobStepStep
   */
  task?: Dbv0036JobStepStepTask;
  /**
   *
   * @type {Dbv0036JobStepStepTres}
   * @memberof Dbv0036JobStepStep
   */
  tres?: Dbv0036JobStepStepTres;
}
/**
 * Heterogeneous job details
 * @export
 * @interface Dbv0036JobStepStepHet
 */
export interface Dbv0036JobStepStepHet {
  /**
   * Parent HetJob component id
   * @type {number}
   * @memberof Dbv0036JobStepStepHet
   */
  component?: number;
}
/**
 * Task properties
 * @export
 * @interface Dbv0036JobStepStepTask
 */
export interface Dbv0036JobStepStepTask {
  /**
   * Task distribution type
   * @type {string}
   * @memberof Dbv0036JobStepStepTask
   */
  distribution?: string;
}
/**
 * TRES usage
 * @export
 * @interface Dbv0036JobStepStepTres
 */
export interface Dbv0036JobStepStepTres {
  /**
   *
   * @type {Dbv0036JobStepStepTresRequested}
   * @memberof Dbv0036JobStepStepTres
   */
  requested?: Dbv0036JobStepStepTresRequested;
  /**
   *
   * @type {Dbv0036JobStepStepTresRequested}
   * @memberof Dbv0036JobStepStepTres
   */
  consumed?: Dbv0036JobStepStepTresRequested;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036JobStepStepTres
   */
  allocated?: Array<object>;
}
/**
 * TRES requested for job
 * @export
 * @interface Dbv0036JobStepStepTresRequested
 */
export interface Dbv0036JobStepStepTresRequested {
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036JobStepStepTresRequested
   */
  average?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036JobStepStepTresRequested
   */
  max?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036JobStepStepTresRequested
   */
  min?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036JobStepStepTresRequested
   */
  total?: Array<object>;
}
/**
 * Task properties
 * @export
 * @interface Dbv0036JobStepTasks
 */
export interface Dbv0036JobStepTasks {
  /**
   * Number of tasks in step
   * @type {number}
   * @memberof Dbv0036JobStepTasks
   */
  count?: number;
}
/**
 * Time properties
 * @export
 * @interface Dbv0036JobStepTime
 */
export interface Dbv0036JobStepTime {
  /**
   * Total time elapsed
   * @type {number}
   * @memberof Dbv0036JobStepTime
   */
  elapsed?: number;
  /**
   * Timestamp of when job ended
   * @type {number}
   * @memberof Dbv0036JobStepTime
   */
  end?: number;
  /**
   * Timestamp of when job started
   * @type {number}
   * @memberof Dbv0036JobStepTime
   */
  start?: number;
  /**
   * Timestamp of when job last suspended
   * @type {number}
   * @memberof Dbv0036JobStepTime
   */
  suspended?: number;
  /**
   *
   * @type {Dbv0036JobTimeSystem}
   * @memberof Dbv0036JobStepTime
   */
  system?: Dbv0036JobTimeSystem;
  /**
   *
   * @type {Dbv0036JobTimeTotal}
   * @memberof Dbv0036JobStepTime
   */
  total?: Dbv0036JobTimeTotal;
  /**
   *
   * @type {Dbv0036JobTimeUser}
   * @memberof Dbv0036JobStepTime
   */
  user?: Dbv0036JobTimeUser;
}
/**
 * Time properties
 * @export
 * @interface Dbv0036JobTime
 */
export interface Dbv0036JobTime {
  /**
   * Total time elapsed
   * @type {number}
   * @memberof Dbv0036JobTime
   */
  elapsed?: number;
  /**
   * Total time eligible to run
   * @type {number}
   * @memberof Dbv0036JobTime
   */
  eligible?: number;
  /**
   * Timestamp of when job ended
   * @type {number}
   * @memberof Dbv0036JobTime
   */
  end?: number;
  /**
   * Timestamp of when job started
   * @type {number}
   * @memberof Dbv0036JobTime
   */
  start?: number;
  /**
   * Timestamp of when job submitted
   * @type {number}
   * @memberof Dbv0036JobTime
   */
  submission?: number;
  /**
   * Timestamp of when job last suspended
   * @type {number}
   * @memberof Dbv0036JobTime
   */
  suspended?: number;
  /**
   *
   * @type {Dbv0036JobTimeSystem}
   * @memberof Dbv0036JobTime
   */
  system?: Dbv0036JobTimeSystem;
  /**
   *
   * @type {Dbv0036JobTimeTotal}
   * @memberof Dbv0036JobTime
   */
  total?: Dbv0036JobTimeTotal;
  /**
   *
   * @type {Dbv0036JobTimeUser}
   * @memberof Dbv0036JobTime
   */
  user?: Dbv0036JobTimeUser;
  /**
   * Job wall clock time limit
   * @type {number}
   * @memberof Dbv0036JobTime
   */
  limit?: number;
}
/**
 * System time values
 * @export
 * @interface Dbv0036JobTimeSystem
 */
export interface Dbv0036JobTimeSystem {
  /**
   * Total number of CPU-seconds used by the system on behalf of the process (in kernel mode), in seconds
   * @type {number}
   * @memberof Dbv0036JobTimeSystem
   */
  seconds?: number;
  /**
   * Total number of CPU-seconds used by the system on behalf of the process (in kernel mode), in microseconds
   * @type {number}
   * @memberof Dbv0036JobTimeSystem
   */
  microseconds?: number;
}
/**
 * System time values
 * @export
 * @interface Dbv0036JobTimeTotal
 */
export interface Dbv0036JobTimeTotal {
  /**
   * Total number of CPU-seconds used by the job, in seconds
   * @type {number}
   * @memberof Dbv0036JobTimeTotal
   */
  seconds?: number;
  /**
   * Total number of CPU-seconds used by the job, in microseconds
   * @type {number}
   * @memberof Dbv0036JobTimeTotal
   */
  microseconds?: number;
}
/**
 * User land time values
 * @export
 * @interface Dbv0036JobTimeUser
 */
export interface Dbv0036JobTimeUser {
  /**
   * Total number of CPU-seconds used by the job in user land, in seconds
   * @type {number}
   * @memberof Dbv0036JobTimeUser
   */
  seconds?: number;
  /**
   * Total number of CPU-seconds used by the job in user land, in microseconds
   * @type {number}
   * @memberof Dbv0036JobTimeUser
   */
  microseconds?: number;
}
/**
 * TRES settings
 * @export
 * @interface Dbv0036JobTres
 */
export interface Dbv0036JobTres {
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036JobTres
   */
  allocated?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036JobTres
   */
  requested?: Array<object>;
}
/**
 * Job assigned wckey details
 * @export
 * @interface Dbv0036JobWckey
 */
export interface Dbv0036JobWckey {
  /**
   * Job assigned wckey
   * @type {string}
   * @memberof Dbv0036JobWckey
   */
  wckey?: string;
  /**
   * wckey flags
   * @type {Array<string>}
   * @memberof Dbv0036JobWckey
   */
  flags?: Array<string>;
}
/**
 * QOS description
 * @export
 * @interface Dbv0036Qos
 */
export interface Dbv0036Qos {
  /**
   * QOS description
   * @type {string}
   * @memberof Dbv0036Qos
   */
  description?: string;
  /**
   * List of properties of QOS
   * @type {Array<string>}
   * @memberof Dbv0036Qos
   */
  flags?: Array<string>;
  /**
   * Database id
   * @type {string}
   * @memberof Dbv0036Qos
   */
  id?: string;
  /**
   *
   * @type {Dbv0036QosLimits}
   * @memberof Dbv0036Qos
   */
  limits?: Dbv0036QosLimits;
  /**
   *
   * @type {Dbv0036QosPreempt}
   * @memberof Dbv0036Qos
   */
  preempt?: Dbv0036QosPreempt;
  /**
   * QOS priority
   * @type {number}
   * @memberof Dbv0036Qos
   */
  priority?: number;
  /**
   * Usage factor
   * @type {number}
   * @memberof Dbv0036Qos
   */
  usage_factor?: number;
  /**
   * Usage threshold
   * @type {number}
   * @memberof Dbv0036Qos
   */
  usage_threshold?: number;
}
/**
 *
 * @export
 * @interface Dbv0036QosInfo
 */
export interface Dbv0036QosInfo {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036QosInfo
   */
  errors?: Array<Dbv0036Error>;
  /**
   * Array of QOS
   * @type {Array<Dbv0036Qos>}
   * @memberof Dbv0036QosInfo
   */
  qos?: Array<Dbv0036Qos>;
}
/**
 * Assigned limits
 * @export
 * @interface Dbv0036QosLimits
 */
export interface Dbv0036QosLimits {
  /**
   *
   * @type {Dbv0036QosLimitsMax}
   * @memberof Dbv0036QosLimits
   */
  max?: Dbv0036QosLimitsMax;
  /**
   *
   * @type {Dbv0036QosLimitsMin}
   * @memberof Dbv0036QosLimits
   */
  min?: Dbv0036QosLimitsMin;
}
/**
 * Limits on max settings
 * @export
 * @interface Dbv0036QosLimitsMax
 */
export interface Dbv0036QosLimitsMax {
  /**
   *
   * @type {Dbv0036QosLimitsMaxWallClock}
   * @memberof Dbv0036QosLimitsMax
   */
  wall_clock?: Dbv0036QosLimitsMaxWallClock;
  /**
   *
   * @type {Dbv0036QosLimitsMaxJobs}
   * @memberof Dbv0036QosLimitsMax
   */
  jobs?: Dbv0036QosLimitsMaxJobs;
  /**
   *
   * @type {Dbv0036QosLimitsMaxAccruing}
   * @memberof Dbv0036QosLimitsMax
   */
  accruing?: Dbv0036QosLimitsMaxAccruing;
  /**
   *
   * @type {Dbv0036QosLimitsMaxTres}
   * @memberof Dbv0036QosLimitsMax
   */
  tres?: Dbv0036QosLimitsMaxTres;
}
/**
 * Limits on accruing priority
 * @export
 * @interface Dbv0036QosLimitsMaxAccruing
 */
export interface Dbv0036QosLimitsMaxAccruing {
  /**
   *
   * @type {Dbv0036QosLimitsMaxAccruingPer}
   * @memberof Dbv0036QosLimitsMaxAccruing
   */
  per?: Dbv0036QosLimitsMaxAccruingPer;
}
/**
 * Max accuring priority per setting
 * @export
 * @interface Dbv0036QosLimitsMaxAccruingPer
 */
export interface Dbv0036QosLimitsMaxAccruingPer {
  /**
   * Max accuring priority per account
   * @type {number}
   * @memberof Dbv0036QosLimitsMaxAccruingPer
   */
  account?: number;
  /**
   * Max accuring priority per user
   * @type {number}
   * @memberof Dbv0036QosLimitsMaxAccruingPer
   */
  user?: number;
}
/**
 * Limits on jobs settings
 * @export
 * @interface Dbv0036QosLimitsMaxJobs
 */
export interface Dbv0036QosLimitsMaxJobs {
  /**
   *
   * @type {Dbv0036QosLimitsMaxJobsPer}
   * @memberof Dbv0036QosLimitsMaxJobs
   */
  per?: Dbv0036QosLimitsMaxJobsPer;
}
/**
 * Limits on jobs per settings
 * @export
 * @interface Dbv0036QosLimitsMaxJobsPer
 */
export interface Dbv0036QosLimitsMaxJobsPer {
  /**
   * Max jobs per account
   * @type {number}
   * @memberof Dbv0036QosLimitsMaxJobsPer
   */
  account?: number;
  /**
   * Max jobs per user
   * @type {number}
   * @memberof Dbv0036QosLimitsMaxJobsPer
   */
  user?: number;
}
/**
 * Limits on TRES
 * @export
 * @interface Dbv0036QosLimitsMaxTres
 */
export interface Dbv0036QosLimitsMaxTres {
  /**
   *
   * @type {Dbv0036QosLimitsMaxTresMinutes}
   * @memberof Dbv0036QosLimitsMaxTres
   */
  minutes?: Dbv0036QosLimitsMaxTresMinutes;
  /**
   *
   * @type {Dbv0036QosLimitsMaxTresPer}
   * @memberof Dbv0036QosLimitsMaxTres
   */
  per?: Dbv0036QosLimitsMaxTresPer;
}
/**
 * Max TRES minutes settings
 * @export
 * @interface Dbv0036QosLimitsMaxTresMinutes
 */
export interface Dbv0036QosLimitsMaxTresMinutes {
  /**
   *
   * @type {Dbv0036QosLimitsMaxTresMinutesPer}
   * @memberof Dbv0036QosLimitsMaxTresMinutes
   */
  per?: Dbv0036QosLimitsMaxTresMinutesPer;
}
/**
 * Max TRES minutes per settings
 * @export
 * @interface Dbv0036QosLimitsMaxTresMinutesPer
 */
export interface Dbv0036QosLimitsMaxTresMinutesPer {
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036QosLimitsMaxTresMinutesPer
   */
  job?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036QosLimitsMaxTresMinutesPer
   */
  account?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036QosLimitsMaxTresMinutesPer
   */
  user?: Array<object>;
}
/**
 * Max TRES per settings
 * @export
 * @interface Dbv0036QosLimitsMaxTresPer
 */
export interface Dbv0036QosLimitsMaxTresPer {
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036QosLimitsMaxTresPer
   */
  account?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036QosLimitsMaxTresPer
   */
  job?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036QosLimitsMaxTresPer
   */
  node?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036QosLimitsMaxTresPer
   */
  user?: Array<object>;
}
/**
 * Limit on wallclock settings
 * @export
 * @interface Dbv0036QosLimitsMaxWallClock
 */
export interface Dbv0036QosLimitsMaxWallClock {
  /**
   *
   * @type {Dbv0036QosLimitsMaxWallClockPer}
   * @memberof Dbv0036QosLimitsMaxWallClock
   */
  per?: Dbv0036QosLimitsMaxWallClockPer;
}
/**
 * Limit on wallclock per settings
 * @export
 * @interface Dbv0036QosLimitsMaxWallClockPer
 */
export interface Dbv0036QosLimitsMaxWallClockPer {
  /**
   * Max wallclock per QOS
   * @type {number}
   * @memberof Dbv0036QosLimitsMaxWallClockPer
   */
  qos?: number;
  /**
   * Max wallclock per job
   * @type {number}
   * @memberof Dbv0036QosLimitsMaxWallClockPer
   */
  job?: number;
}
/**
 * Min limit settings
 * @export
 * @interface Dbv0036QosLimitsMin
 */
export interface Dbv0036QosLimitsMin {
  /**
   * Min priority threshold
   * @type {number}
   * @memberof Dbv0036QosLimitsMin
   */
  priority_threshold?: number;
  /**
   *
   * @type {Dbv0036QosLimitsMinTres}
   * @memberof Dbv0036QosLimitsMin
   */
  tres?: Dbv0036QosLimitsMinTres;
}
/**
 * Min tres settings
 * @export
 * @interface Dbv0036QosLimitsMinTres
 */
export interface Dbv0036QosLimitsMinTres {
  /**
   *
   * @type {Dbv0036QosLimitsMinTresPer}
   * @memberof Dbv0036QosLimitsMinTres
   */
  per?: Dbv0036QosLimitsMinTresPer;
}
/**
 * Min tres per settings
 * @export
 * @interface Dbv0036QosLimitsMinTresPer
 */
export interface Dbv0036QosLimitsMinTresPer {
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0036QosLimitsMinTresPer
   */
  job?: Array<object>;
}
/**
 * Preemption settings
 * @export
 * @interface Dbv0036QosPreempt
 */
export interface Dbv0036QosPreempt {
  /**
   * List of preemptable QOS
   * @type {Array<string>}
   * @memberof Dbv0036QosPreempt
   */
  list?: Array<string>;
  /**
   * List of preemption modes
   * @type {Array<string>}
   * @memberof Dbv0036QosPreempt
   */
  mode?: Array<string>;
  /**
   * Grace period (s) before jobs can preempted
   * @type {number}
   * @memberof Dbv0036QosPreempt
   */
  exempt_time?: number;
}
/**
 *
 * @export
 * @interface Dbv0036ResponseAccountDelete
 */
export interface Dbv0036ResponseAccountDelete {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036ResponseAccountDelete
   */
  errors?: Array<Dbv0036Error>;
}
/**
 *
 * @export
 * @interface Dbv0036ResponseAssociationDelete
 */
export interface Dbv0036ResponseAssociationDelete {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036ResponseAssociationDelete
   */
  errors?: Array<Dbv0036Error>;
}
/**
 *
 * @export
 * @interface Dbv0036ResponseClusterAdd
 */
export interface Dbv0036ResponseClusterAdd {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036ResponseClusterAdd
   */
  errors?: Array<Dbv0036Error>;
}
/**
 *
 * @export
 * @interface Dbv0036ResponseClusterDelete
 */
export interface Dbv0036ResponseClusterDelete {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036ResponseClusterDelete
   */
  errors?: Array<Dbv0036Error>;
}
/**
 *
 * @export
 * @interface Dbv0036ResponseQosDelete
 */
export interface Dbv0036ResponseQosDelete {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036ResponseQosDelete
   */
  errors?: Array<Dbv0036Error>;
}
/**
 *
 * @export
 * @interface Dbv0036ResponseTres
 */
export interface Dbv0036ResponseTres {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036ResponseTres
   */
  errors?: Array<Dbv0036Error>;
}
/**
 *
 * @export
 * @interface Dbv0036ResponseUserDelete
 */
export interface Dbv0036ResponseUserDelete {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036ResponseUserDelete
   */
  errors?: Array<Dbv0036Error>;
}
/**
 *
 * @export
 * @interface Dbv0036ResponseUserUpdate
 */
export interface Dbv0036ResponseUserUpdate {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036ResponseUserUpdate
   */
  errors?: Array<Dbv0036Error>;
}
/**
 *
 * @export
 * @interface Dbv0036ResponseWckeyAdd
 */
export interface Dbv0036ResponseWckeyAdd {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036ResponseWckeyAdd
   */
  errors?: Array<Dbv0036Error>;
}
/**
 *
 * @export
 * @interface Dbv0036ResponseWckeyDelete
 */
export interface Dbv0036ResponseWckeyDelete {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036ResponseWckeyDelete
   */
  errors?: Array<Dbv0036Error>;
}
/**
 *
 * @export
 * @interface Dbv0036TresInfo
 */
export interface Dbv0036TresInfo {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036TresInfo
   */
  errors?: Array<Dbv0036Error>;
  /**
   * Array of tres
   * @type {Array<Array<object>>}
   * @memberof Dbv0036TresInfo
   */
  tres?: Array<Array<object>>;
}
/**
 * User description
 * @export
 * @interface Dbv0036User
 */
export interface Dbv0036User {
  /**
   * Description of administrator level
   * @type {string}
   * @memberof Dbv0036User
   */
  administrator_level?: string;
  /**
   *
   * @type {Dbv0036UserAssociations}
   * @memberof Dbv0036User
   */
  associations?: Dbv0036UserAssociations;
  /**
   * List of assigned coordinators
   * @type {Array<Dbv0036CoordinatorInfo>}
   * @memberof Dbv0036User
   */
  coordinators?: Array<Dbv0036CoordinatorInfo>;
  /**
   *
   * @type {Dbv0036UserDefault}
   * @memberof Dbv0036User
   */
  default?: Dbv0036UserDefault;
  /**
   * User name
   * @type {string}
   * @memberof Dbv0036User
   */
  name?: string;
}
/**
 * Assigned associations
 * @export
 * @interface Dbv0036UserAssociations
 */
export interface Dbv0036UserAssociations {
  /**
   *
   * @type {Dbv0036AssociationShortInfo}
   * @memberof Dbv0036UserAssociations
   */
  root?: Dbv0036AssociationShortInfo;
}
/**
 * Default settings
 * @export
 * @interface Dbv0036UserDefault
 */
export interface Dbv0036UserDefault {
  /**
   * Default account name
   * @type {string}
   * @memberof Dbv0036UserDefault
   */
  account?: string;
  /**
   * Default wckey
   * @type {string}
   * @memberof Dbv0036UserDefault
   */
  wckey?: string;
}
/**
 *
 * @export
 * @interface Dbv0036UserInfo
 */
export interface Dbv0036UserInfo {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036UserInfo
   */
  errors?: Array<Dbv0036Error>;
  /**
   * Array of users
   * @type {Array<Dbv0036User>}
   * @memberof Dbv0036UserInfo
   */
  users?: Array<Dbv0036User>;
}
/**
 *
 * @export
 * @interface Dbv0036Wckey
 */
export interface Dbv0036Wckey {
  /**
   * List of assigned accounts
   * @type {Array<string>}
   * @memberof Dbv0036Wckey
   */
  accounts?: Array<string>;
  /**
   * Cluster name
   * @type {string}
   * @memberof Dbv0036Wckey
   */
  cluster?: string;
  /**
   * wckey database unique id
   * @type {number}
   * @memberof Dbv0036Wckey
   */
  id?: number;
  /**
   * wckey name
   * @type {string}
   * @memberof Dbv0036Wckey
   */
  name?: string;
  /**
   * wckey user
   * @type {string}
   * @memberof Dbv0036Wckey
   */
  user?: string;
  /**
   * List of properties of wckey
   * @type {Array<string>}
   * @memberof Dbv0036Wckey
   */
  flags?: Array<string>;
}
/**
 *
 * @export
 * @interface Dbv0036WckeyInfo
 */
export interface Dbv0036WckeyInfo {
  /**
   * Slurm errors
   * @type {Array<Dbv0036Error>}
   * @memberof Dbv0036WckeyInfo
   */
  errors?: Array<Dbv0036Error>;
  /**
   * List of wckeys
   * @type {Array<Dbv0036Wckey>}
   * @memberof Dbv0036WckeyInfo
   */
  wckeys?: Array<Dbv0036Wckey>;
}
/**
 * Account description
 * @export
 * @interface Dbv0037Account
 */
export interface Dbv0037Account {
  /**
   * List of assigned associations
   * @type {Array<Dbv0037AssociationShortInfo>}
   * @memberof Dbv0037Account
   */
  associations?: Array<Dbv0037AssociationShortInfo>;
  /**
   * List of assigned coordinators
   * @type {Array<Dbv0037CoordinatorInfo>}
   * @memberof Dbv0037Account
   */
  coordinators?: Array<Dbv0037CoordinatorInfo>;
  /**
   * Description of account
   * @type {string}
   * @memberof Dbv0037Account
   */
  description?: string;
  /**
   * Name of account
   * @type {string}
   * @memberof Dbv0037Account
   */
  name?: string;
  /**
   * Assigned organization of account
   * @type {string}
   * @memberof Dbv0037Account
   */
  organization?: string;
  /**
   * List of properties of account
   * @type {Array<string>}
   * @memberof Dbv0037Account
   */
  flags?: Array<string>;
}
/**
 *
 * @export
 * @interface Dbv0037AccountInfo
 */
export interface Dbv0037AccountInfo {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037AccountInfo
   */
  errors?: Array<Dbv0037Error>;
  /**
   * List of accounts
   * @type {Array<Dbv0037Account>}
   * @memberof Dbv0037AccountInfo
   */
  accounts?: Array<Dbv0037Account>;
}
/**
 *
 * @export
 * @interface Dbv0037AccountResponse
 */
export interface Dbv0037AccountResponse {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037AccountResponse
   */
  errors?: Array<Dbv0037Error>;
}
/**
 * Association description
 * @export
 * @interface Dbv0037Association
 */
export interface Dbv0037Association {
  /**
   * Assigned account
   * @type {string}
   * @memberof Dbv0037Association
   */
  account?: string;
  /**
   * Assigned cluster
   * @type {string}
   * @memberof Dbv0037Association
   */
  cluster?: string;
  /**
   *
   * @type {Dbv0036AssociationDefault}
   * @memberof Dbv0037Association
   */
  default?: Dbv0036AssociationDefault;
  /**
   * List of properties of association
   * @type {Array<string>}
   * @memberof Dbv0037Association
   */
  flags?: Array<string>;
  /**
   *
   * @type {Dbv0037AssociationMax}
   * @memberof Dbv0037Association
   */
  max?: Dbv0037AssociationMax;
  /**
   *
   * @type {Dbv0036AssociationMin}
   * @memberof Dbv0037Association
   */
  min?: Dbv0036AssociationMin;
  /**
   * Parent account name
   * @type {string}
   * @memberof Dbv0037Association
   */
  parent_account?: string;
  /**
   * Assigned partition
   * @type {string}
   * @memberof Dbv0037Association
   */
  partition?: string;
  /**
   * Assigned priority
   * @type {number}
   * @memberof Dbv0037Association
   */
  priority?: number;
  /**
   * Assigned QOS
   * @type {Array<string>}
   * @memberof Dbv0037Association
   */
  qos?: Array<string>;
  /**
   * Raw fairshare shares
   * @type {number}
   * @memberof Dbv0037Association
   */
  shares_raw?: number;
  /**
   *
   * @type {Dbv0036AssociationUsage}
   * @memberof Dbv0037Association
   */
  usage?: Dbv0036AssociationUsage;
  /**
   * Assigned user
   * @type {string}
   * @memberof Dbv0037Association
   */
  user?: string;
}
/**
 * Max settings
 * @export
 * @interface Dbv0037AssociationMax
 */
export interface Dbv0037AssociationMax {
  /**
   *
   * @type {Dbv0036AssociationMaxJobs}
   * @memberof Dbv0037AssociationMax
   */
  jobs?: Dbv0036AssociationMaxJobs;
  /**
   *
   * @type {Dbv0036AssociationMaxPer}
   * @memberof Dbv0037AssociationMax
   */
  per?: Dbv0036AssociationMaxPer;
  /**
   *
   * @type {Dbv0037AssociationMaxTres}
   * @memberof Dbv0037AssociationMax
   */
  tres?: Dbv0037AssociationMaxTres;
}
/**
 * Max TRES settings
 * @export
 * @interface Dbv0037AssociationMaxTres
 */
export interface Dbv0037AssociationMaxTres {
  /**
   *
   * @type {Dbv0037AssociationMaxTresPer}
   * @memberof Dbv0037AssociationMaxTres
   */
  per?: Dbv0037AssociationMaxTresPer;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037AssociationMaxTres
   */
  total?: Array<object>;
  /**
   *
   * @type {Dbv0037AssociationMaxTresMinutes}
   * @memberof Dbv0037AssociationMaxTres
   */
  minutes?: Dbv0037AssociationMaxTresMinutes;
}
/**
 * Max TRES minutes settings
 * @export
 * @interface Dbv0037AssociationMaxTresMinutes
 */
export interface Dbv0037AssociationMaxTresMinutes {
  /**
   *
   * @type {Dbv0037AssociationMaxTresMinutesPer}
   * @memberof Dbv0037AssociationMaxTresMinutes
   */
  per?: Dbv0037AssociationMaxTresMinutesPer;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037AssociationMaxTresMinutes
   */
  total?: Array<object>;
}
/**
 * Max TRES minutes per settings
 * @export
 * @interface Dbv0037AssociationMaxTresMinutesPer
 */
export interface Dbv0037AssociationMaxTresMinutesPer {
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037AssociationMaxTresMinutesPer
   */
  job?: Array<object>;
}
/**
 * Max TRES per settings
 * @export
 * @interface Dbv0037AssociationMaxTresPer
 */
export interface Dbv0037AssociationMaxTresPer {
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037AssociationMaxTresPer
   */
  job?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037AssociationMaxTresPer
   */
  node?: Array<object>;
}
/**
 *
 * @export
 * @interface Dbv0037AssociationShortInfo
 */
export interface Dbv0037AssociationShortInfo {
  /**
   * Account name
   * @type {string}
   * @memberof Dbv0037AssociationShortInfo
   */
  account?: string;
  /**
   * Cluster name
   * @type {string}
   * @memberof Dbv0037AssociationShortInfo
   */
  cluster?: string;
  /**
   * Partition name (optional)
   * @type {string}
   * @memberof Dbv0037AssociationShortInfo
   */
  partition?: string;
  /**
   * User name
   * @type {string}
   * @memberof Dbv0037AssociationShortInfo
   */
  user?: string;
}
/**
 *
 * @export
 * @interface Dbv0037AssociationsInfo
 */
export interface Dbv0037AssociationsInfo {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037AssociationsInfo
   */
  errors?: Array<Dbv0037Error>;
  /**
   * Array of associations
   * @type {Array<Dbv0037Association>}
   * @memberof Dbv0037AssociationsInfo
   */
  associations?: Array<Dbv0037Association>;
}
/**
 *
 * @export
 * @interface Dbv0037ClusterInfo
 */
export interface Dbv0037ClusterInfo {
  /**
   *
   * @type {Dbv0036ClusterInfoController}
   * @memberof Dbv0037ClusterInfo
   */
  controller?: Dbv0036ClusterInfoController;
  /**
   * List of properties of cluster
   * @type {Array<string>}
   * @memberof Dbv0037ClusterInfo
   */
  flags?: Array<string>;
  /**
   * Cluster name
   * @type {string}
   * @memberof Dbv0037ClusterInfo
   */
  name?: string;
  /**
   * Assigned nodes
   * @type {string}
   * @memberof Dbv0037ClusterInfo
   */
  nodes?: string;
  /**
   * Configured select plugin
   * @type {string}
   * @memberof Dbv0037ClusterInfo
   */
  select_plugin?: string;
  /**
   *
   * @type {Dbv0037ClusterInfoAssociations}
   * @memberof Dbv0037ClusterInfo
   */
  associations?: Dbv0037ClusterInfoAssociations;
  /**
   * Number rpc version
   * @type {number}
   * @memberof Dbv0037ClusterInfo
   */
  rpc_version?: number;
  /**
   * List of TRES in cluster
   * @type {Array<Dbv0037ResponseTres>}
   * @memberof Dbv0037ClusterInfo
   */
  tres?: Array<Dbv0037ResponseTres>;
}
/**
 * Information about associations
 * @export
 * @interface Dbv0037ClusterInfoAssociations
 */
export interface Dbv0037ClusterInfoAssociations {
  /**
   *
   * @type {Dbv0037AssociationShortInfo}
   * @memberof Dbv0037ClusterInfoAssociations
   */
  root?: Dbv0037AssociationShortInfo;
}
/**
 *
 * @export
 * @interface Dbv0037ConfigInfo
 */
export interface Dbv0037ConfigInfo {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037ConfigInfo
   */
  errors?: Array<Dbv0037Error>;
  /**
   * Array of TRES
   * @type {Array<Array<object>>}
   * @memberof Dbv0037ConfigInfo
   */
  tres?: Array<Array<object>>;
  /**
   * Array of accounts
   * @type {Array<Dbv0037Account>}
   * @memberof Dbv0037ConfigInfo
   */
  accounts?: Array<Dbv0037Account>;
  /**
   * Array of associations
   * @type {Array<Dbv0037Association>}
   * @memberof Dbv0037ConfigInfo
   */
  associations?: Array<Dbv0037Association>;
  /**
   * Array of users
   * @type {Array<Dbv0037User>}
   * @memberof Dbv0037ConfigInfo
   */
  users?: Array<Dbv0037User>;
  /**
   * Array of qos
   * @type {Array<Dbv0037Qos>}
   * @memberof Dbv0037ConfigInfo
   */
  qos?: Array<Dbv0037Qos>;
  /**
   * Array of wckeys
   * @type {Array<Dbv0037Wckey>}
   * @memberof Dbv0037ConfigInfo
   */
  wckeys?: Array<Dbv0037Wckey>;
}
/**
 *
 * @export
 * @interface Dbv0037ConfigResponse
 */
export interface Dbv0037ConfigResponse {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037ConfigResponse
   */
  errors?: Array<Dbv0037Error>;
}
/**
 *
 * @export
 * @interface Dbv0037CoordinatorInfo
 */
export interface Dbv0037CoordinatorInfo {
  /**
   * Name of user
   * @type {string}
   * @memberof Dbv0037CoordinatorInfo
   */
  name?: string;
  /**
   * If user is coordinator of this account directly or coordinator status was inheirted from a higher account in the tree
   * @type {number}
   * @memberof Dbv0037CoordinatorInfo
   */
  direct?: number;
}
/**
 *
 * @export
 * @interface Dbv0037Diag
 */
export interface Dbv0037Diag {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037Diag
   */
  errors?: Array<Dbv0037Error>;
  /**
   * Unix timestamp of start time
   * @type {number}
   * @memberof Dbv0037Diag
   */
  time_start?: number;
  /**
   *
   * @type {Array<Dbv0036DiagRollups>}
   * @memberof Dbv0037Diag
   */
  rollups?: Array<Dbv0036DiagRollups>;
  /**
   *
   * @type {Array<Dbv0036DiagRPCs>}
   * @memberof Dbv0037Diag
   */
  RPCs?: Array<Dbv0036DiagRPCs>;
  /**
   *
   * @type {Array<Dbv0036DiagUsers>}
   * @memberof Dbv0037Diag
   */
  users?: Array<Dbv0036DiagUsers>;
}
/**
 *
 * @export
 * @interface Dbv0037Error
 */
export interface Dbv0037Error {
  /**
   * Error number
   * @type {number}
   * @memberof Dbv0037Error
   */
  errno?: number;
  /**
   * Error message
   * @type {string}
   * @memberof Dbv0037Error
   */
  error?: string;
}
/**
 * Single job description
 * @export
 * @interface Dbv0037Job
 */
export interface Dbv0037Job {
  /**
   * Account charged by job
   * @type {string}
   * @memberof Dbv0037Job
   */
  account?: string;
  /**
   *
   * @type {Dbv0036JobComment}
   * @memberof Dbv0037Job
   */
  comment?: Dbv0036JobComment;
  /**
   * Nodes allocated to job
   * @type {string}
   * @memberof Dbv0037Job
   */
  allocation_nodes?: string;
  /**
   *
   * @type {Dbv0036JobArray}
   * @memberof Dbv0037Job
   */
  array?: Dbv0036JobArray;
  /**
   *
   * @type {Dbv0036JobTime}
   * @memberof Dbv0037Job
   */
  time?: Dbv0036JobTime;
  /**
   *
   * @type {Dbv0037AssociationShortInfo}
   * @memberof Dbv0037Job
   */
  association?: Dbv0037AssociationShortInfo;
  /**
   * Assigned cluster
   * @type {string}
   * @memberof Dbv0037Job
   */
  cluster?: string;
  /**
   * Constraints on job
   * @type {string}
   * @memberof Dbv0037Job
   */
  constraints?: string;
  /**
   *
   * @type {Dbv0037JobExitCode}
   * @memberof Dbv0037Job
   */
  derived_exit_code?: Dbv0037JobExitCode;
  /**
   *
   * @type {Dbv0037JobExitCode}
   * @memberof Dbv0037Job
   */
  exit_code?: Dbv0037JobExitCode;
  /**
   * List of properties of job
   * @type {Array<string>}
   * @memberof Dbv0037Job
   */
  flags?: Array<string>;
  /**
   * User\'s group to run job
   * @type {string}
   * @memberof Dbv0037Job
   */
  group?: string;
  /**
   *
   * @type {Dbv0036JobHet}
   * @memberof Dbv0037Job
   */
  het?: Dbv0036JobHet;
  /**
   * Job id
   * @type {number}
   * @memberof Dbv0037Job
   */
  job_id?: number;
  /**
   * Assigned job name
   * @type {string}
   * @memberof Dbv0037Job
   */
  name?: string;
  /**
   *
   * @type {Dbv0036JobMcs}
   * @memberof Dbv0037Job
   */
  mcs?: Dbv0036JobMcs;
  /**
   * List of nodes allocated for job
   * @type {string}
   * @memberof Dbv0037Job
   */
  nodes?: string;
  /**
   * Assigned job\'s partition
   * @type {string}
   * @memberof Dbv0037Job
   */
  partition?: string;
  /**
   * Priority
   * @type {number}
   * @memberof Dbv0037Job
   */
  priority?: number;
  /**
   * Assigned qos name
   * @type {string}
   * @memberof Dbv0037Job
   */
  qos?: string;
  /**
   *
   * @type {Dbv0036JobRequired}
   * @memberof Dbv0037Job
   */
  required?: Dbv0036JobRequired;
  /**
   * User who requested job killed
   * @type {string}
   * @memberof Dbv0037Job
   */
  kill_request_user?: string;
  /**
   *
   * @type {Dbv0036JobReservation}
   * @memberof Dbv0037Job
   */
  reservation?: Dbv0036JobReservation;
  /**
   *
   * @type {Dbv0037JobState}
   * @memberof Dbv0037Job
   */
  state?: Dbv0037JobState;
  /**
   * Job step description
   * @type {Array<Dbv0037JobStep>}
   * @memberof Dbv0037Job
   */
  steps?: Array<Dbv0037JobStep>;
  /**
   *
   * @type {Dbv0037JobTres}
   * @memberof Dbv0037Job
   */
  tres?: Dbv0037JobTres;
  /**
   * Job user
   * @type {string}
   * @memberof Dbv0037Job
   */
  user?: string;
  /**
   *
   * @type {Dbv0036JobWckey}
   * @memberof Dbv0037Job
   */
  wckey?: Dbv0036JobWckey;
  /**
   * Directory where job was initially started
   * @type {string}
   * @memberof Dbv0037Job
   */
  working_directory?: string;
}
/**
 *
 * @export
 * @interface Dbv0037JobExitCode
 */
export interface Dbv0037JobExitCode {
  /**
   * Job exit status
   * @type {string}
   * @memberof Dbv0037JobExitCode
   */
  status?: string;
  /**
   * Return code from parent process
   * @type {number}
   * @memberof Dbv0037JobExitCode
   */
  return_code?: number;
  /**
   *
   * @type {Dbv0036JobExitCodeSignal}
   * @memberof Dbv0037JobExitCode
   */
  signal?: Dbv0036JobExitCodeSignal;
}
/**
 *
 * @export
 * @interface Dbv0037JobInfo
 */
export interface Dbv0037JobInfo {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037JobInfo
   */
  errors?: Array<Dbv0037Error>;
  /**
   * Array of jobs
   * @type {Array<Dbv0037Job>}
   * @memberof Dbv0037JobInfo
   */
  jobs?: Array<Dbv0037Job>;
}
/**
 * State properties of job
 * @export
 * @interface Dbv0037JobState
 */
export interface Dbv0037JobState {
  /**
   * Current state of job
   * @type {string}
   * @memberof Dbv0037JobState
   */
  current?: string;
  /**
   * Last reason job didn\'t run
   * @type {string}
   * @memberof Dbv0037JobState
   */
  reason?: string;
}
/**
 *
 * @export
 * @interface Dbv0037JobStep
 */
export interface Dbv0037JobStep {
  /**
   *
   * @type {Dbv0036JobStepTime}
   * @memberof Dbv0037JobStep
   */
  time?: Dbv0036JobStepTime;
  /**
   *
   * @type {Dbv0037JobExitCode}
   * @memberof Dbv0037JobStep
   */
  exit_code?: Dbv0037JobExitCode;
  /**
   *
   * @type {Dbv0036JobStepNodes}
   * @memberof Dbv0037JobStep
   */
  nodes?: Dbv0036JobStepNodes;
  /**
   *
   * @type {Dbv0036JobStepTasks}
   * @memberof Dbv0037JobStep
   */
  tasks?: Dbv0036JobStepTasks;
  /**
   * First process PID
   * @type {string}
   * @memberof Dbv0037JobStep
   */
  pid?: string;
  /**
   *
   * @type {Dbv0036JobStepCPU}
   * @memberof Dbv0037JobStep
   */
  CPU?: Dbv0036JobStepCPU;
  /**
   * User who requested job killed
   * @type {string}
   * @memberof Dbv0037JobStep
   */
  kill_request_user?: string;
  /**
   * State of job step
   * @type {string}
   * @memberof Dbv0037JobStep
   */
  state?: string;
  /**
   *
   * @type {Dbv0036JobStepStatistics}
   * @memberof Dbv0037JobStep
   */
  statistics?: Dbv0036JobStepStatistics;
  /**
   *
   * @type {Dbv0037JobStepStep}
   * @memberof Dbv0037JobStep
   */
  step?: Dbv0037JobStepStep;
}
/**
 * Step details
 * @export
 * @interface Dbv0037JobStepStep
 */
export interface Dbv0037JobStepStep {
  /**
   * Parent job id
   * @type {number}
   * @memberof Dbv0037JobStepStep
   */
  job_id?: number;
  /**
   *
   * @type {Dbv0036JobStepStepHet}
   * @memberof Dbv0037JobStepStep
   */
  het?: Dbv0036JobStepStepHet;
  /**
   * Step id
   * @type {string}
   * @memberof Dbv0037JobStepStep
   */
  id?: string;
  /**
   * Step name
   * @type {string}
   * @memberof Dbv0037JobStepStep
   */
  name?: string;
  /**
   *
   * @type {Dbv0036JobStepStepTask}
   * @memberof Dbv0037JobStepStep
   */
  task?: Dbv0036JobStepStepTask;
  /**
   *
   * @type {Dbv0037JobStepStepTres}
   * @memberof Dbv0037JobStepStep
   */
  tres?: Dbv0037JobStepStepTres;
}
/**
 * TRES usage
 * @export
 * @interface Dbv0037JobStepStepTres
 */
export interface Dbv0037JobStepStepTres {
  /**
   *
   * @type {Dbv0037JobStepStepTresRequested}
   * @memberof Dbv0037JobStepStepTres
   */
  requested?: Dbv0037JobStepStepTresRequested;
  /**
   *
   * @type {Dbv0037JobStepStepTresRequested}
   * @memberof Dbv0037JobStepStepTres
   */
  consumed?: Dbv0037JobStepStepTresRequested;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037JobStepStepTres
   */
  allocated?: Array<object>;
}
/**
 * TRES requested for job
 * @export
 * @interface Dbv0037JobStepStepTresRequested
 */
export interface Dbv0037JobStepStepTresRequested {
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037JobStepStepTresRequested
   */
  average?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037JobStepStepTresRequested
   */
  max?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037JobStepStepTresRequested
   */
  min?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037JobStepStepTresRequested
   */
  total?: Array<object>;
}
/**
 * TRES settings
 * @export
 * @interface Dbv0037JobTres
 */
export interface Dbv0037JobTres {
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037JobTres
   */
  allocated?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037JobTres
   */
  requested?: Array<object>;
}
/**
 * QOS description
 * @export
 * @interface Dbv0037Qos
 */
export interface Dbv0037Qos {
  /**
   * QOS description
   * @type {string}
   * @memberof Dbv0037Qos
   */
  description?: string;
  /**
   * List of properties of QOS
   * @type {Array<string>}
   * @memberof Dbv0037Qos
   */
  flags?: Array<string>;
  /**
   * Database id
   * @type {string}
   * @memberof Dbv0037Qos
   */
  id?: string;
  /**
   *
   * @type {Dbv0037QosLimits}
   * @memberof Dbv0037Qos
   */
  limits?: Dbv0037QosLimits;
  /**
   *
   * @type {Dbv0036QosPreempt}
   * @memberof Dbv0037Qos
   */
  preempt?: Dbv0036QosPreempt;
  /**
   * QOS priority
   * @type {number}
   * @memberof Dbv0037Qos
   */
  priority?: number;
  /**
   * Usage factor
   * @type {number}
   * @memberof Dbv0037Qos
   */
  usage_factor?: number;
  /**
   * Usage threshold
   * @type {number}
   * @memberof Dbv0037Qos
   */
  usage_threshold?: number;
}
/**
 *
 * @export
 * @interface Dbv0037QosInfo
 */
export interface Dbv0037QosInfo {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037QosInfo
   */
  errors?: Array<Dbv0037Error>;
  /**
   * Array of QOS
   * @type {Array<Dbv0037Qos>}
   * @memberof Dbv0037QosInfo
   */
  qos?: Array<Dbv0037Qos>;
}
/**
 * Assigned limits
 * @export
 * @interface Dbv0037QosLimits
 */
export interface Dbv0037QosLimits {
  /**
   *
   * @type {Dbv0037QosLimitsMax}
   * @memberof Dbv0037QosLimits
   */
  max?: Dbv0037QosLimitsMax;
  /**
   *
   * @type {Dbv0037QosLimitsMin}
   * @memberof Dbv0037QosLimits
   */
  min?: Dbv0037QosLimitsMin;
}
/**
 * Limits on max settings
 * @export
 * @interface Dbv0037QosLimitsMax
 */
export interface Dbv0037QosLimitsMax {
  /**
   *
   * @type {Dbv0036QosLimitsMaxWallClock}
   * @memberof Dbv0037QosLimitsMax
   */
  wall_clock?: Dbv0036QosLimitsMaxWallClock;
  /**
   *
   * @type {Dbv0036QosLimitsMaxJobs}
   * @memberof Dbv0037QosLimitsMax
   */
  jobs?: Dbv0036QosLimitsMaxJobs;
  /**
   *
   * @type {Dbv0036QosLimitsMaxAccruing}
   * @memberof Dbv0037QosLimitsMax
   */
  accruing?: Dbv0036QosLimitsMaxAccruing;
  /**
   *
   * @type {Dbv0037QosLimitsMaxTres}
   * @memberof Dbv0037QosLimitsMax
   */
  tres?: Dbv0037QosLimitsMaxTres;
}
/**
 * Limits on TRES
 * @export
 * @interface Dbv0037QosLimitsMaxTres
 */
export interface Dbv0037QosLimitsMaxTres {
  /**
   *
   * @type {Dbv0037QosLimitsMaxTresMinutes}
   * @memberof Dbv0037QosLimitsMaxTres
   */
  minutes?: Dbv0037QosLimitsMaxTresMinutes;
  /**
   *
   * @type {Dbv0037QosLimitsMaxTresPer}
   * @memberof Dbv0037QosLimitsMaxTres
   */
  per?: Dbv0037QosLimitsMaxTresPer;
}
/**
 * Max TRES minutes settings
 * @export
 * @interface Dbv0037QosLimitsMaxTresMinutes
 */
export interface Dbv0037QosLimitsMaxTresMinutes {
  /**
   *
   * @type {Dbv0037QosLimitsMaxTresMinutesPer}
   * @memberof Dbv0037QosLimitsMaxTresMinutes
   */
  per?: Dbv0037QosLimitsMaxTresMinutesPer;
}
/**
 * Max TRES minutes per settings
 * @export
 * @interface Dbv0037QosLimitsMaxTresMinutesPer
 */
export interface Dbv0037QosLimitsMaxTresMinutesPer {
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037QosLimitsMaxTresMinutesPer
   */
  job?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037QosLimitsMaxTresMinutesPer
   */
  account?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037QosLimitsMaxTresMinutesPer
   */
  user?: Array<object>;
}
/**
 * Max TRES per settings
 * @export
 * @interface Dbv0037QosLimitsMaxTresPer
 */
export interface Dbv0037QosLimitsMaxTresPer {
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037QosLimitsMaxTresPer
   */
  account?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037QosLimitsMaxTresPer
   */
  job?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037QosLimitsMaxTresPer
   */
  node?: Array<object>;
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037QosLimitsMaxTresPer
   */
  user?: Array<object>;
}
/**
 * Min limit settings
 * @export
 * @interface Dbv0037QosLimitsMin
 */
export interface Dbv0037QosLimitsMin {
  /**
   * Min priority threshold
   * @type {number}
   * @memberof Dbv0037QosLimitsMin
   */
  priority_threshold?: number;
  /**
   *
   * @type {Dbv0037QosLimitsMinTres}
   * @memberof Dbv0037QosLimitsMin
   */
  tres?: Dbv0037QosLimitsMinTres;
}
/**
 * Min tres settings
 * @export
 * @interface Dbv0037QosLimitsMinTres
 */
export interface Dbv0037QosLimitsMinTres {
  /**
   *
   * @type {Dbv0037QosLimitsMinTresPer}
   * @memberof Dbv0037QosLimitsMinTres
   */
  per?: Dbv0037QosLimitsMinTresPer;
}
/**
 * Min tres per settings
 * @export
 * @interface Dbv0037QosLimitsMinTresPer
 */
export interface Dbv0037QosLimitsMinTresPer {
  /**
   * TRES list of attributes
   * @type {Array<object>}
   * @memberof Dbv0037QosLimitsMinTresPer
   */
  job?: Array<object>;
}
/**
 *
 * @export
 * @interface Dbv0037ResponseAccountDelete
 */
export interface Dbv0037ResponseAccountDelete {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037ResponseAccountDelete
   */
  errors?: Array<Dbv0037Error>;
}
/**
 *
 * @export
 * @interface Dbv0037ResponseAssociationDelete
 */
export interface Dbv0037ResponseAssociationDelete {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037ResponseAssociationDelete
   */
  errors?: Array<Dbv0037Error>;
}
/**
 *
 * @export
 * @interface Dbv0037ResponseClusterAdd
 */
export interface Dbv0037ResponseClusterAdd {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037ResponseClusterAdd
   */
  errors?: Array<Dbv0037Error>;
}
/**
 *
 * @export
 * @interface Dbv0037ResponseClusterDelete
 */
export interface Dbv0037ResponseClusterDelete {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037ResponseClusterDelete
   */
  errors?: Array<Dbv0037Error>;
}
/**
 *
 * @export
 * @interface Dbv0037ResponseQosDelete
 */
export interface Dbv0037ResponseQosDelete {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037ResponseQosDelete
   */
  errors?: Array<Dbv0037Error>;
}
/**
 *
 * @export
 * @interface Dbv0037ResponseTres
 */
export interface Dbv0037ResponseTres {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037ResponseTres
   */
  errors?: Array<Dbv0037Error>;
}
/**
 *
 * @export
 * @interface Dbv0037ResponseUserDelete
 */
export interface Dbv0037ResponseUserDelete {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037ResponseUserDelete
   */
  errors?: Array<Dbv0037Error>;
}
/**
 *
 * @export
 * @interface Dbv0037ResponseUserUpdate
 */
export interface Dbv0037ResponseUserUpdate {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037ResponseUserUpdate
   */
  errors?: Array<Dbv0037Error>;
}
/**
 *
 * @export
 * @interface Dbv0037ResponseWckeyAdd
 */
export interface Dbv0037ResponseWckeyAdd {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037ResponseWckeyAdd
   */
  errors?: Array<Dbv0037Error>;
}
/**
 *
 * @export
 * @interface Dbv0037ResponseWckeyDelete
 */
export interface Dbv0037ResponseWckeyDelete {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037ResponseWckeyDelete
   */
  errors?: Array<Dbv0037Error>;
}
/**
 *
 * @export
 * @interface Dbv0037TresInfo
 */
export interface Dbv0037TresInfo {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037TresInfo
   */
  errors?: Array<Dbv0037Error>;
  /**
   * Array of tres
   * @type {Array<Array<object>>}
   * @memberof Dbv0037TresInfo
   */
  tres?: Array<Array<object>>;
}
/**
 * User description
 * @export
 * @interface Dbv0037User
 */
export interface Dbv0037User {
  /**
   * Description of administrator level
   * @type {string}
   * @memberof Dbv0037User
   */
  administrator_level?: string;
  /**
   *
   * @type {Dbv0037UserAssociations}
   * @memberof Dbv0037User
   */
  associations?: Dbv0037UserAssociations;
  /**
   * List of assigned coordinators
   * @type {Array<Dbv0037CoordinatorInfo>}
   * @memberof Dbv0037User
   */
  coordinators?: Array<Dbv0037CoordinatorInfo>;
  /**
   *
   * @type {Dbv0036UserDefault}
   * @memberof Dbv0037User
   */
  default?: Dbv0036UserDefault;
  /**
   * User name
   * @type {string}
   * @memberof Dbv0037User
   */
  name?: string;
}
/**
 * Assigned associations
 * @export
 * @interface Dbv0037UserAssociations
 */
export interface Dbv0037UserAssociations {
  /**
   *
   * @type {Dbv0037AssociationShortInfo}
   * @memberof Dbv0037UserAssociations
   */
  root?: Dbv0037AssociationShortInfo;
}
/**
 *
 * @export
 * @interface Dbv0037UserInfo
 */
export interface Dbv0037UserInfo {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037UserInfo
   */
  errors?: Array<Dbv0037Error>;
  /**
   * Array of users
   * @type {Array<Dbv0037User>}
   * @memberof Dbv0037UserInfo
   */
  users?: Array<Dbv0037User>;
}
/**
 *
 * @export
 * @interface Dbv0037Wckey
 */
export interface Dbv0037Wckey {
  /**
   * List of assigned accounts
   * @type {Array<string>}
   * @memberof Dbv0037Wckey
   */
  accounts?: Array<string>;
  /**
   * Cluster name
   * @type {string}
   * @memberof Dbv0037Wckey
   */
  cluster?: string;
  /**
   * wckey database unique id
   * @type {number}
   * @memberof Dbv0037Wckey
   */
  id?: number;
  /**
   * wckey name
   * @type {string}
   * @memberof Dbv0037Wckey
   */
  name?: string;
  /**
   * wckey user
   * @type {string}
   * @memberof Dbv0037Wckey
   */
  user?: string;
  /**
   * List of properties of wckey
   * @type {Array<string>}
   * @memberof Dbv0037Wckey
   */
  flags?: Array<string>;
}
/**
 *
 * @export
 * @interface Dbv0037WckeyInfo
 */
export interface Dbv0037WckeyInfo {
  /**
   * Slurm errors
   * @type {Array<Dbv0037Error>}
   * @memberof Dbv0037WckeyInfo
   */
  errors?: Array<Dbv0037Error>;
  /**
   * List of wckeys
   * @type {Array<Dbv0037Wckey>}
   * @memberof Dbv0037WckeyInfo
   */
  wckeys?: Array<Dbv0037Wckey>;
}
/**
 *
 * @export
 * @interface JobProperties
 */
export interface JobProperties {
  /**
   * Charge resources used by this job to specified account.
   * @type {string}
   * @memberof JobProperties
   */
  account?: string;
  /**
   * Define the job accounting and profiling sampling intervals.
   * @type {string}
   * @memberof JobProperties
   */
  account_gather_freqency?: string;
  /**
   * Arguments to the script.
   * @type {Array<string>}
   * @memberof JobProperties
   */
  argv?: Array<string>;
  /**
   * Submit a job array, multiple jobs to be executed with identical parameters. The indexes specification identifies what array index values should be used.
   * @type {string}
   * @memberof JobProperties
   */
  array?: string;
  /**
   * features required for batch script\'s node
   * @type {string}
   * @memberof JobProperties
   */
  batch_features?: string;
  /**
   * Submit the batch script to the Slurm controller immediately, like normal, but tell the controller to defer the allocation of the job until the specified time.
   * @type {string}
   * @memberof JobProperties
   */
  begin_time?: string;
  /**
   * Burst buffer specification.
   * @type {string}
   * @memberof JobProperties
   */
  burst_buffer?: string;
  /**
   * Specifies features that a federated cluster must have to have a sibling job submitted to it.
   * @type {string}
   * @memberof JobProperties
   */
  cluster_constraints?: string;
  /**
   * An arbitrary comment.
   * @type {string}
   * @memberof JobProperties
   */
  comment?: string;
  /**
   * node features required by job.
   * @type {string}
   * @memberof JobProperties
   */
  constraints?: string;
  /**
   * Count of specialized threads per node reserved by the job for system operations and not used by the application.
   * @type {number}
   * @memberof JobProperties
   */
  core_specification?: number;
  /**
   * Restrict node selection to nodes with at least the specified number of cores per socket.
   * @type {number}
   * @memberof JobProperties
   */
  cores_per_socket?: number;
  /**
   * Cpu binding
   * @type {string}
   * @memberof JobProperties
   */
  cpu_binding?: string;
  /**
   * Cpu binding hint
   * @type {string}
   * @memberof JobProperties
   */
  cpu_binding_hint?: string;
  /**
   * Request that job steps initiated by srun commands inside this sbatch script be run at some requested frequency if possible, on the CPUs selected for the step on the compute node(s).
   * @type {string}
   * @memberof JobProperties
   */
  cpu_frequency?: string;
  /**
   * Number of CPUs requested per allocated GPU.
   * @type {string}
   * @memberof JobProperties
   */
  cpus_per_gpu?: string;
  /**
   * Advise the Slurm controller that ensuing job steps will require ncpus number of processors per task.
   * @type {number}
   * @memberof JobProperties
   */
  cpus_per_task?: number;
  /**
   * Instruct Slurm to connect the batch script\'s standard output directly to the file name.
   * @type {string}
   * @memberof JobProperties
   */
  current_working_directory?: string;
  /**
   * Remove the job if no ending is possible before this deadline (start > (deadline - time[-min])).
   * @type {string}
   * @memberof JobProperties
   */
  deadline?: string;
  /**
   * Do not reboot nodes in order to satisfied this job\'s feature specification if the job has been eligible to run for less than this time period.
   * @type {number}
   * @memberof JobProperties
   */
  delay_boot?: number;
  /**
   * Defer the start of this job until the specified dependencies have been satisfied completed.
   * @type {string}
   * @memberof JobProperties
   */
  dependency?: string;
  /**
   * Specify alternate distribution methods for remote processes.
   * @type {string}
   * @memberof JobProperties
   */
  distribution?: string;
  /**
   * Dictionary of environment entries.
   * @type {object}
   * @memberof JobProperties
   */
  environment?: object;
  /**
   *
   * @type {string | boolean}
   * @memberof JobProperties
   */
  exclusive?: string | boolean;
  /**
   * Load new login environment for user on job node.
   * @type {boolean}
   * @memberof JobProperties
   */
  get_user_environment?: boolean;
  /**
   * Specifies a comma delimited list of generic consumable resources.
   * @type {string}
   * @memberof JobProperties
   */
  gres?: string;
  /**
   * Specify generic resource task binding options.
   * @type {string}
   * @memberof JobProperties
   */
  gres_flags?: JobPropertiesGresFlagsEnum;
  /**
   * Requested binding of tasks to GPU.
   * @type {string}
   * @memberof JobProperties
   */
  gpu_binding?: string;
  /**
   * Requested GPU frequency.
   * @type {string}
   * @memberof JobProperties
   */
  gpu_frequency?: string;
  /**
   * GPUs per job.
   * @type {string}
   * @memberof JobProperties
   */
  gpus?: string;
  /**
   * GPUs per node.
   * @type {string}
   * @memberof JobProperties
   */
  gpus_per_node?: string;
  /**
   * GPUs per socket.
   * @type {string}
   * @memberof JobProperties
   */
  gpus_per_socket?: string;
  /**
   * GPUs per task.
   * @type {string}
   * @memberof JobProperties
   */
  gpus_per_task?: string;
  /**
   * Specify the job is to be submitted in a held state (priority of zero).
   * @type {boolean}
   * @memberof JobProperties
   */
  hold?: boolean;
  /**
   * If a job has an invalid dependency, then Slurm is to terminate it.
   * @type {boolean}
   * @memberof JobProperties
   */
  kill_on_invalid_dependency?: boolean;
  /**
   * Specification of licenses (or other resources available on all nodes of the cluster) which must be allocated to this job.
   * @type {string}
   * @memberof JobProperties
   */
  licenses?: string;
  /**
   * Notify user by email when certain event types occur.
   * @type {string}
   * @memberof JobProperties
   */
  mail_type?: string;
  /**
   * User to receive email notification of state changes as defined by mail_type.
   * @type {string}
   * @memberof JobProperties
   */
  mail_user?: string;
  /**
   * This parameter is a group among the groups of the user.
   * @type {string}
   * @memberof JobProperties
   */
  mcs_label?: string;
  /**
   * Bind tasks to memory.
   * @type {string}
   * @memberof JobProperties
   */
  memory_binding?: string;
  /**
   * Minimum real memory per cpu (MB).
   * @type {number}
   * @memberof JobProperties
   */
  memory_per_cpu?: number;
  /**
   * Minimum memory required per allocated GPU.
   * @type {number}
   * @memberof JobProperties
   */
  memory_per_gpu?: number;
  /**
   * Minimum real memory per node (MB).
   * @type {number}
   * @memberof JobProperties
   */
  memory_per_node?: number;
  /**
   * Minimum number of CPUs per node.
   * @type {number}
   * @memberof JobProperties
   */
  minimum_cpus_per_node?: number;
  /**
   * If a range of node counts is given, prefer the smaller count.
   * @type {boolean}
   * @memberof JobProperties
   */
  minimum_nodes?: boolean;
  /**
   * Specify a name for the job allocation.
   * @type {string}
   * @memberof JobProperties
   */
  name?: string;
  /**
   * Run the job with an adjusted scheduling priority within Slurm.
   * @type {string}
   * @memberof JobProperties
   */
  nice?: string;
  /**
   * Do not automatically terminate a job if one of the nodes it has been allocated fails.
   * @type {boolean}
   * @memberof JobProperties
   */
  no_kill?: boolean;
  /**
   *
   * @type {number | Array<number>}
   * @memberof JobProperties
   */
  nodes?: number | Array<number>;
  /**
   * Open the output and error files using append or truncate mode as specified.
   * @type {string}
   * @memberof JobProperties
   */
  open_mode?: JobPropertiesOpenModeEnum;
  /**
   * Request a specific partition for the resource allocation.
   * @type {string}
   * @memberof JobProperties
   */
  partition?: string;
  /**
   * Request a specific job priority.
   * @type {string}
   * @memberof JobProperties
   */
  priority?: string;
  /**
   * Request a quality of service for the job.
   * @type {string}
   * @memberof JobProperties
   */
  qos?: string;
  /**
   * Specifies that the batch job should eligible to being requeue.
   * @type {boolean}
   * @memberof JobProperties
   */
  requeue?: boolean;
  /**
   * Allocate resources for the job from the named reservation.
   * @type {string}
   * @memberof JobProperties
   */
  reservation?: string;
  /**
   * When a job is within sig_time seconds of its end time, send it the signal sig_num.
   * @type {string}
   * @memberof JobProperties
   */
  signal?: string;
  /**
   * Restrict node selection to nodes with at least the specified number of sockets.
   * @type {number}
   * @memberof JobProperties
   */
  sockets_per_node?: number;
  /**
   * Spread the job allocation over as many nodes as possible and attempt to evenly distribute tasks across the allocated nodes.
   * @type {boolean}
   * @memberof JobProperties
   */
  spread_job?: boolean;
  /**
   * Instruct Slurm to connect the batch script\'s standard error directly to the file name.
   * @type {string}
   * @memberof JobProperties
   */
  standard_error?: string;
  /**
   * Instruct Slurm to connect the batch script\'s standard input directly to the file name specified.
   * @type {string}
   * @memberof JobProperties
   */
  standard_in?: string;
  /**
   * Instruct Slurm to connect the batch script\'s standard output directly to the file name.
   * @type {string}
   * @memberof JobProperties
   */
  standard_out?: string;
  /**
   * Advises the Slurm controller that job steps run within the allocation will launch a maximum of number tasks and to provide for sufficient resources.
   * @type {number}
   * @memberof JobProperties
   */
  tasks?: number;
  /**
   * Request the maximum ntasks be invoked on each core.
   * @type {number}
   * @memberof JobProperties
   */
  tasks_per_core?: number;
  /**
   * Request the maximum ntasks be invoked on each node.
   * @type {number}
   * @memberof JobProperties
   */
  tasks_per_node?: number;
  /**
   * Request the maximum ntasks be invoked on each socket.
   * @type {number}
   * @memberof JobProperties
   */
  tasks_per_socket?: number;
  /**
   * Count of specialized threads per node reserved by the job for system operations and not used by the application.
   * @type {number}
   * @memberof JobProperties
   */
  thread_specification?: number;
  /**
   * Restrict node selection to nodes with at least the specified number of threads per core.
   * @type {number}
   * @memberof JobProperties
   */
  threads_per_core?: number;
  /**
   * Step time limit.
   * @type {number}
   * @memberof JobProperties
   */
  time_limit?: number;
  /**
   * Minimum run time in minutes.
   * @type {number}
   * @memberof JobProperties
   */
  time_minimum?: number;
  /**
   * Do not begin execution until all nodes are ready for use.
   * @type {boolean}
   * @memberof JobProperties
   */
  wait_all_nodes?: boolean;
  /**
   * Specify wckey to be used with job.
   * @type {string}
   * @memberof JobProperties
   */
  wckey?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum JobPropertiesGresFlagsEnum {
  DisableBinding = 'disable-binding',
  EnforceBinding = 'enforce-binding',
}
/**
 * @export
 * @enum {string}
 */
export enum JobPropertiesOpenModeEnum {
  Append = 'append',
  Truncate = 'truncate',
}

/**
 * @type Signal
 * @export
 */
export type Signal = SignalOneOf | number;

/**
 * POSIX signal name
 * @export
 * @enum {string}
 */

export enum SignalOneOf {
  Hup = 'HUP',
  Int = 'INT',
  Quit = 'QUIT',
  Abrt = 'ABRT',
  Kill = 'KILL',
  Alrm = 'ALRM',
  Term = 'TERM',
  Usr1 = 'USR1',
  Usr2 = 'USR2',
  Urg = 'URG',
  Cont = 'CONT',
  Stop = 'STOP',
  Tstp = 'TSTP',
  Ttin = 'TTIN',
  Ttou = 'TTOU',
}

/**
 *
 * @export
 * @interface V0036Diag
 */
export interface V0036Diag {
  /**
   * slurm errors
   * @type {Array<V0036Error>}
   * @memberof V0036Diag
   */
  errors?: Array<V0036Error>;
  /**
   *
   * @type {V0037DiagStatistics}
   * @memberof V0036Diag
   */
  statistics?: V0037DiagStatistics;
}
/**
 *
 * @export
 * @interface V0036Error
 */
export interface V0036Error {
  /**
   * error message
   * @type {string}
   * @memberof V0036Error
   */
  error?: string;
  /**
   * error number
   * @type {number}
   * @memberof V0036Error
   */
  errno?: number;
}
/**
 *
 * @export
 * @interface V0036JobProperties
 */
export interface V0036JobProperties {
  /**
   * Charge resources used by this job to specified account.
   * @type {string}
   * @memberof V0036JobProperties
   */
  account?: string;
  /**
   * Define the job accounting and profiling sampling intervals.
   * @type {string}
   * @memberof V0036JobProperties
   */
  account_gather_freqency?: string;
  /**
   * Arguments to the script.
   * @type {Array<string>}
   * @memberof V0036JobProperties
   */
  argv?: Array<string>;
  /**
   * Submit a job array, multiple jobs to be executed with identical parameters. The indexes specification identifies what array index values should be used.
   * @type {string}
   * @memberof V0036JobProperties
   */
  array?: string;
  /**
   * features required for batch script\'s node
   * @type {string}
   * @memberof V0036JobProperties
   */
  batch_features?: string;
  /**
   * Submit the batch script to the Slurm controller immediately, like normal, but tell the controller to defer the allocation of the job until the specified time.
   * @type {string}
   * @memberof V0036JobProperties
   */
  begin_time?: string;
  /**
   * Burst buffer specification.
   * @type {string}
   * @memberof V0036JobProperties
   */
  burst_buffer?: string;
  /**
   * Specifies features that a federated cluster must have to have a sibling job submitted to it.
   * @type {string}
   * @memberof V0036JobProperties
   */
  cluster_constraints?: string;
  /**
   * An arbitrary comment.
   * @type {string}
   * @memberof V0036JobProperties
   */
  comment?: string;
  /**
   * node features required by job.
   * @type {string}
   * @memberof V0036JobProperties
   */
  constraints?: string;
  /**
   * Count of specialized threads per node reserved by the job for system operations and not used by the application.
   * @type {number}
   * @memberof V0036JobProperties
   */
  core_specification?: number;
  /**
   * Restrict node selection to nodes with at least the specified number of cores per socket.
   * @type {number}
   * @memberof V0036JobProperties
   */
  cores_per_socket?: number;
  /**
   * Cpu binding
   * @type {string}
   * @memberof V0036JobProperties
   */
  cpu_binding?: string;
  /**
   * Cpu binding hint
   * @type {string}
   * @memberof V0036JobProperties
   */
  cpu_binding_hint?: string;
  /**
   * Request that job steps initiated by srun commands inside this sbatch script be run at some requested frequency if possible, on the CPUs selected for the step on the compute node(s).
   * @type {string}
   * @memberof V0036JobProperties
   */
  cpu_frequency?: string;
  /**
   * Number of CPUs requested per allocated GPU.
   * @type {string}
   * @memberof V0036JobProperties
   */
  cpus_per_gpu?: string;
  /**
   * Advise the Slurm controller that ensuing job steps will require ncpus number of processors per task.
   * @type {number}
   * @memberof V0036JobProperties
   */
  cpus_per_task?: number;
  /**
   * Instruct Slurm to connect the batch script\'s standard output directly to the file name.
   * @type {string}
   * @memberof V0036JobProperties
   */
  current_working_directory?: string;
  /**
   * Remove the job if no ending is possible before this deadline (start > (deadline - time[-min])).
   * @type {string}
   * @memberof V0036JobProperties
   */
  deadline?: string;
  /**
   * Do not reboot nodes in order to satisfied this job\'s feature specification if the job has been eligible to run for less than this time period.
   * @type {number}
   * @memberof V0036JobProperties
   */
  delay_boot?: number;
  /**
   * Defer the start of this job until the specified dependencies have been satisfied completed.
   * @type {string}
   * @memberof V0036JobProperties
   */
  dependency?: string;
  /**
   * Specify alternate distribution methods for remote processes.
   * @type {string}
   * @memberof V0036JobProperties
   */
  distribution?: string;
  /**
   * Dictionary of environment entries.
   * @type {object}
   * @memberof V0036JobProperties
   */
  environment: object;
  /**
   * The job allocation can share nodes just other users with the \"user\" option or with the \"mcs\" option).
   * @type {string}
   * @memberof V0036JobProperties
   */
  exclusive?: V0036JobPropertiesExclusiveEnum;
  /**
   * Load new login environment for user on job node.
   * @type {boolean}
   * @memberof V0036JobProperties
   */
  get_user_environment?: boolean;
  /**
   * Specifies a comma delimited list of generic consumable resources.
   * @type {string}
   * @memberof V0036JobProperties
   */
  gres?: string;
  /**
   * Specify generic resource task binding options.
   * @type {string}
   * @memberof V0036JobProperties
   */
  gres_flags?: V0036JobPropertiesGresFlagsEnum;
  /**
   * Requested binding of tasks to GPU.
   * @type {string}
   * @memberof V0036JobProperties
   */
  gpu_binding?: string;
  /**
   * Requested GPU frequency.
   * @type {string}
   * @memberof V0036JobProperties
   */
  gpu_frequency?: string;
  /**
   * GPUs per job.
   * @type {string}
   * @memberof V0036JobProperties
   */
  gpus?: string;
  /**
   * GPUs per node.
   * @type {string}
   * @memberof V0036JobProperties
   */
  gpus_per_node?: string;
  /**
   * GPUs per socket.
   * @type {string}
   * @memberof V0036JobProperties
   */
  gpus_per_socket?: string;
  /**
   * GPUs per task.
   * @type {string}
   * @memberof V0036JobProperties
   */
  gpus_per_task?: string;
  /**
   * Specify the job is to be submitted in a held state (priority of zero).
   * @type {boolean}
   * @memberof V0036JobProperties
   */
  hold?: boolean;
  /**
   * If a job has an invalid dependency, then Slurm is to terminate it.
   * @type {boolean}
   * @memberof V0036JobProperties
   */
  kill_on_invalid_dependency?: boolean;
  /**
   * Specification of licenses (or other resources available on all nodes of the cluster) which must be allocated to this job.
   * @type {string}
   * @memberof V0036JobProperties
   */
  licenses?: string;
  /**
   * Notify user by email when certain event types occur.
   * @type {string}
   * @memberof V0036JobProperties
   */
  mail_type?: string;
  /**
   * User to receive email notification of state changes as defined by mail_type.
   * @type {string}
   * @memberof V0036JobProperties
   */
  mail_user?: string;
  /**
   * This parameter is a group among the groups of the user.
   * @type {string}
   * @memberof V0036JobProperties
   */
  mcs_label?: string;
  /**
   * Bind tasks to memory.
   * @type {string}
   * @memberof V0036JobProperties
   */
  memory_binding?: string;
  /**
   * Minimum real memory per cpu (MB).
   * @type {number}
   * @memberof V0036JobProperties
   */
  memory_per_cpu?: number;
  /**
   * Minimum memory required per allocated GPU.
   * @type {number}
   * @memberof V0036JobProperties
   */
  memory_per_gpu?: number;
  /**
   * Minimum real memory per node (MB).
   * @type {number}
   * @memberof V0036JobProperties
   */
  memory_per_node?: number;
  /**
   * Minimum number of CPUs per node.
   * @type {number}
   * @memberof V0036JobProperties
   */
  minimum_cpus_per_node?: number;
  /**
   * If a range of node counts is given, prefer the smaller count.
   * @type {boolean}
   * @memberof V0036JobProperties
   */
  minimum_nodes?: boolean;
  /**
   * Specify a name for the job allocation.
   * @type {string}
   * @memberof V0036JobProperties
   */
  name?: string;
  /**
   * Run the job with an adjusted scheduling priority within Slurm.
   * @type {string}
   * @memberof V0036JobProperties
   */
  nice?: string;
  /**
   * Do not automatically terminate a job if one of the nodes it has been allocated fails.
   * @type {boolean}
   * @memberof V0036JobProperties
   */
  no_kill?: boolean;
  /**
   * Request that a minimum of minnodes nodes and a maximum node count.
   * @type {Array<number>}
   * @memberof V0036JobProperties
   */
  nodes?: Array<number>;
  /**
   * Open the output and error files using append or truncate mode as specified.
   * @type {string}
   * @memberof V0036JobProperties
   */
  open_mode?: V0036JobPropertiesOpenModeEnum;
  /**
   * Request a specific partition for the resource allocation.
   * @type {string}
   * @memberof V0036JobProperties
   */
  partition?: string;
  /**
   * Request a specific job priority.
   * @type {string}
   * @memberof V0036JobProperties
   */
  priority?: string;
  /**
   * Request a quality of service for the job.
   * @type {string}
   * @memberof V0036JobProperties
   */
  qos?: string;
  /**
   * Specifies that the batch job should eligible to being requeue.
   * @type {boolean}
   * @memberof V0036JobProperties
   */
  requeue?: boolean;
  /**
   * Allocate resources for the job from the named reservation.
   * @type {string}
   * @memberof V0036JobProperties
   */
  reservation?: string;
  /**
   * When a job is within sig_time seconds of its end time, send it the signal sig_num.
   * @type {string}
   * @memberof V0036JobProperties
   */
  signal?: string;
  /**
   * Restrict node selection to nodes with at least the specified number of sockets.
   * @type {number}
   * @memberof V0036JobProperties
   */
  sockets_per_node?: number;
  /**
   * Spread the job allocation over as many nodes as possible and attempt to evenly distribute tasks across the allocated nodes.
   * @type {boolean}
   * @memberof V0036JobProperties
   */
  spread_job?: boolean;
  /**
   * Instruct Slurm to connect the batch script\'s standard error directly to the file name.
   * @type {string}
   * @memberof V0036JobProperties
   */
  standard_error?: string;
  /**
   * Instruct Slurm to connect the batch script\'s standard input directly to the file name specified.
   * @type {string}
   * @memberof V0036JobProperties
   */
  standard_in?: string;
  /**
   * Instruct Slurm to connect the batch script\'s standard output directly to the file name.
   * @type {string}
   * @memberof V0036JobProperties
   */
  standard_out?: string;
  /**
   * Advises the Slurm controller that job steps run within the allocation will launch a maximum of number tasks and to provide for sufficient resources.
   * @type {number}
   * @memberof V0036JobProperties
   */
  tasks?: number;
  /**
   * Request the maximum ntasks be invoked on each core.
   * @type {number}
   * @memberof V0036JobProperties
   */
  tasks_per_core?: number;
  /**
   * Request the maximum ntasks be invoked on each node.
   * @type {number}
   * @memberof V0036JobProperties
   */
  tasks_per_node?: number;
  /**
   * Request the maximum ntasks be invoked on each socket.
   * @type {number}
   * @memberof V0036JobProperties
   */
  tasks_per_socket?: number;
  /**
   * Count of specialized threads per node reserved by the job for system operations and not used by the application.
   * @type {number}
   * @memberof V0036JobProperties
   */
  thread_specification?: number;
  /**
   * Restrict node selection to nodes with at least the specified number of threads per core.
   * @type {number}
   * @memberof V0036JobProperties
   */
  threads_per_core?: number;
  /**
   * Step time limit.
   * @type {number}
   * @memberof V0036JobProperties
   */
  time_limit?: number;
  /**
   * Minimum run time in minutes.
   * @type {number}
   * @memberof V0036JobProperties
   */
  time_minimum?: number;
  /**
   * Do not begin execution until all nodes are ready for use.
   * @type {boolean}
   * @memberof V0036JobProperties
   */
  wait_all_nodes?: boolean;
  /**
   * Specify wckey to be used with job.
   * @type {string}
   * @memberof V0036JobProperties
   */
  wckey?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum V0036JobPropertiesExclusiveEnum {
  User = 'user',
  Mcs = 'mcs',
  True = 'true',
  False = 'false',
}
/**
 * @export
 * @enum {string}
 */
export enum V0036JobPropertiesGresFlagsEnum {
  DisableBinding = 'disable-binding',
  EnforceBinding = 'enforce-binding',
}
/**
 * @export
 * @enum {string}
 */
export enum V0036JobPropertiesOpenModeEnum {
  Append = 'append',
  Truncate = 'truncate',
}

/**
 *
 * @export
 * @interface V0036JobResources
 */
export interface V0036JobResources {
  /**
   * list of assigned job nodes
   * @type {string}
   * @memberof V0036JobResources
   */
  nodes?: string;
  /**
   * number of assigned job cpus
   * @type {number}
   * @memberof V0036JobResources
   */
  allocated_cpus?: number;
  /**
   * number of assigned job hosts
   * @type {number}
   * @memberof V0036JobResources
   */
  allocated_hosts?: number;
  /**
   * node allocations
   * @type {Array<V0036NodeAllocation>}
   * @memberof V0036JobResources
   */
  allocated_nodes?: Array<V0036NodeAllocation>;
}
/**
 *
 * @export
 * @interface V0036JobResponseProperties
 */
export interface V0036JobResponseProperties {
  /**
   * Charge resources used by this job to specified account
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  account?: string;
  /**
   * time job is eligible for running
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  accrue_time?: string;
  /**
   * administrator\'s arbitrary comment
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  admin_comment?: string;
  /**
   * job_id of a job array or 0 if N/A
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  array_job_id?: string;
  /**
   * task_id of a job array
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  array_task_id?: string;
  /**
   * Maximum number of running array tasks
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  array_max_tasks?: string;
  /**
   * string expression of task IDs in this record
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  array_task_string?: string;
  /**
   * association id for job
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  association_id?: string;
  /**
   * features required for batch script\'s node
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  batch_features?: string;
  /**
   * if batch: queued job with script
   * @type {boolean}
   * @memberof V0036JobResponseProperties
   */
  batch_flag?: boolean;
  /**
   * name of host running batch script
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  batch_host?: string;
  /**
   * Job flags
   * @type {Array<string>}
   * @memberof V0036JobResponseProperties
   */
  flags?: Array<string>;
  /**
   * burst buffer specifications
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  burst_buffer?: string;
  /**
   * burst buffer state info
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  burst_buffer_state?: string;
  /**
   * name of cluster that the job is on
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  cluster?: string;
  /**
   * comma separated list of required cluster features
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  cluster_features?: string;
  /**
   * command to be executed
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  command?: string;
  /**
   * arbitrary comment
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  comment?: string;
  /**
   * job requires contiguous nodes
   * @type {boolean}
   * @memberof V0036JobResponseProperties
   */
  contiguous?: boolean;
  /**
   * specialized core count
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  core_spec?: string;
  /**
   * specialized thread count
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  thread_spec?: string;
  /**
   * cores per socket required by job
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  cores_per_socket?: string;
  /**
   * billable TRES
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  billable_tres?: string;
  /**
   * number of processors required for each task
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  cpus_per_task?: string;
  /**
   * Minimum cpu frequency
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  cpu_frequency_minimum?: string;
  /**
   * Maximum cpu frequency
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  cpu_frequency_maximum?: string;
  /**
   * cpu frequency governor
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  cpu_frequency_governor?: string;
  /**
   * semicolon delimited list of TRES=# values
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  cpus_per_tres?: string;
  /**
   * job start deadline
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  deadline?: string;
  /**
   * command to be executed
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  delay_boot?: string;
  /**
   * synchronize job execution with other jobs
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  dependency?: string;
  /**
   * highest exit code of all job steps
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  derived_exit_code?: string;
  /**
   * time job is eligible for running
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  eligible_time?: string;
  /**
   * time of termination, actual or expected
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  end_time?: string;
  /**
   * comma separated list of excluded nodes
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  excluded_nodes?: string;
  /**
   * exit code for job
   * @type {number}
   * @memberof V0036JobResponseProperties
   */
  exit_code?: number;
  /**
   * comma separated list of required features
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  features?: string;
  /**
   * Origin cluster\'s name
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  federation_origin?: string;
  /**
   * string of active sibling names
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  federation_siblings_active?: string;
  /**
   * string of viable sibling names
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  federation_siblings_viable?: string;
  /**
   * Job flags
   * @type {Array<string>}
   * @memberof V0036JobResponseProperties
   */
  gres_detail?: Array<string>;
  /**
   * group job submitted as
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  group_id?: string;
  /**
   * job ID
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  job_id?: string;
  /**
   *
   * @type {V0036JobResources}
   * @memberof V0036JobResponseProperties
   */
  job_resources?: V0036JobResources;
  /**
   * state of the job
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  job_state?: string;
  /**
   * last time job was evaluated for scheduling
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  last_sched_evaluation?: string;
  /**
   * licenses required by the job
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  licenses?: string;
  /**
   * maximum number of cpus usable by job
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  max_cpus?: string;
  /**
   * maximum number of nodes usable by job
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  max_nodes?: string;
  /**
   * mcs_label if mcs plugin in use
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  mcs_label?: string;
  /**
   * semicolon delimited list of TRES=# values
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  memory_per_tres?: string;
  /**
   * name of the job
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  name?: string;
  /**
   * list of nodes allocated to job
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  nodes?: string;
  /**
   * requested priority change
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  nice?: string;
  /**
   * number of tasks to invoke on each core
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  tasks_per_core?: string;
  /**
   * number of tasks to invoke on each socket
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  tasks_per_socket?: string;
  /**
   * number of tasks to invoke on each board
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  tasks_per_board?: string;
  /**
   * minimum number of cpus required by job
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  cpus?: string;
  /**
   * minimum number of nodes required by job
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  node_count?: string;
  /**
   * requested task count
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  tasks?: string;
  /**
   * job ID of hetjob leader
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  het_job_id?: string;
  /**
   * job IDs for all components
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  het_job_id_set?: string;
  /**
   * HetJob component offset from leader
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  het_job_offset?: string;
  /**
   * name of assigned partition
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  partition?: string;
  /**
   * minimum real memory per node
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  memory_per_node?: string;
  /**
   * minimum real memory per cpu
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  memory_per_cpu?: string;
  /**
   * minimum # CPUs per node
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  minimum_cpus_per_node?: string;
  /**
   * minimum tmp disk per node
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  minimum_tmp_disk_per_node?: string;
  /**
   * preemption signal time
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  preempt_time?: string;
  /**
   * time job ran prior to last suspend
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  pre_sus_time?: string;
  /**
   * relative priority of the job
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  priority?: string;
  /**
   * Job profiling requested
   * @type {Array<string>}
   * @memberof V0036JobResponseProperties
   */
  profile?: Array<string>;
  /**
   * Quality of Service
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  qos?: string;
  /**
   * node reboot requested before start
   * @type {boolean}
   * @memberof V0036JobResponseProperties
   */
  reboot?: boolean;
  /**
   * comma separated list of required nodes
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  required_nodes?: string;
  /**
   * enable or disable job requeue option
   * @type {boolean}
   * @memberof V0036JobResponseProperties
   */
  requeue?: boolean;
  /**
   * time of latest size change
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  resize_time?: string;
  /**
   * count of job restarts
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  restart_cnt?: string;
  /**
   * reservation name
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  resv_name?: string;
  /**
   * type and if job can share nodes with other jobs
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  shared?: string;
  /**
   * details requested
   * @type {Array<string>}
   * @memberof V0036JobResponseProperties
   */
  show_flags?: Array<string>;
  /**
   * sockets per board required by job
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  sockets_per_board?: string;
  /**
   * sockets per node required by job
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  sockets_per_node?: string;
  /**
   * time execution begins, actual or expected
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  start_time?: string;
  /**
   * optional details for state_reason
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  state_description?: string;
  /**
   * reason job still pending or failed
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  state_reason?: string;
  /**
   * pathname of job\'s stderr file
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  standard_error?: string;
  /**
   * pathname of job\'s stdin file
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  standard_input?: string;
  /**
   * pathname of job\'s stdout file
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  standard_output?: string;
  /**
   * time of job submission
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  submit_time?: string;
  /**
   * time job last suspended or resumed
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  suspend_time?: string;
  /**
   * slurmctld\'s arbitrary comment
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  system_comment?: string;
  /**
   * maximum run time in minutes
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  time_limit?: string;
  /**
   * minimum run time in minutes
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  time_minimum?: string;
  /**
   * threads per core required by job
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  threads_per_core?: string;
  /**
   * Task to TRES binding directives
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  tres_bind?: string;
  /**
   * TRES frequency directives
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  tres_freq?: string;
  /**
   * semicolon delimited list of TRES=# values
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  tres_per_job?: string;
  /**
   * semicolon delimited list of TRES=# values
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  tres_per_node?: string;
  /**
   * semicolon delimited list of TRES=# values
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  tres_per_socket?: string;
  /**
   * semicolon delimited list of TRES=# values
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  tres_per_task?: string;
  /**
   * tres reqeusted in the job
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  tres_req_str?: string;
  /**
   * tres used in the job
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  tres_alloc_str?: string;
  /**
   * user id the job runs as
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  user_id?: string;
  /**
   * user the job runs as
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  user_name?: string;
  /**
   * wckey for job
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  wckey?: string;
  /**
   * pathname of working directory
   * @type {string}
   * @memberof V0036JobResponseProperties
   */
  current_working_directory?: string;
}
/**
 *
 * @export
 * @interface V0036JobSubmission
 */
export interface V0036JobSubmission {
  /**
   * Executable script (full contents) to run in batch step
   * @type {string}
   * @memberof V0036JobSubmission
   */
  script: string;
  /**
   *
   * @type {V0036JobProperties}
   * @memberof V0036JobSubmission
   */
  job?: V0036JobProperties;
  /**
   * Properties of an HetJob
   * @type {Array<V0036JobProperties>}
   * @memberof V0036JobSubmission
   */
  jobs?: Array<V0036JobProperties>;
}
/**
 *
 * @export
 * @interface V0036JobSubmissionResponse
 */
export interface V0036JobSubmissionResponse {
  /**
   * slurm errors
   * @type {Array<V0036Error>}
   * @memberof V0036JobSubmissionResponse
   */
  errors?: Array<V0036Error>;
  /**
   * new job ID
   * @type {number}
   * @memberof V0036JobSubmissionResponse
   */
  job_id?: number;
  /**
   * new job step ID
   * @type {string}
   * @memberof V0036JobSubmissionResponse
   */
  step_id?: string;
  /**
   * Message to user from job_submit plugin
   * @type {string}
   * @memberof V0036JobSubmissionResponse
   */
  job_submit_user_msg?: string;
}
/**
 *
 * @export
 * @interface V0036JobsResponse
 */
export interface V0036JobsResponse {
  /**
   * slurm errors
   * @type {Array<V0036Error>}
   * @memberof V0036JobsResponse
   */
  errors?: Array<V0036Error>;
  /**
   * job descriptions
   * @type {Array<V0036JobResponseProperties>}
   * @memberof V0036JobsResponse
   */
  jobs?: Array<V0036JobResponseProperties>;
}
/**
 *
 * @export
 * @interface V0036Node
 */
export interface V0036Node {
  /**
   * computer architecture
   * @type {string}
   * @memberof V0036Node
   */
  architecture?: string;
  /**
   * BcastAddr
   * @type {string}
   * @memberof V0036Node
   */
  burstbuffer_network_address?: string;
  /**
   * total number of boards per node
   * @type {number}
   * @memberof V0036Node
   */
  boards?: number;
  /**
   * timestamp of node boot
   * @type {number}
   * @memberof V0036Node
   */
  boot_time?: number;
  /**
   * Arbitrary comment
   * @type {string}
   * @memberof V0036Node
   */
  comment?: string;
  /**
   * number of cores per socket
   * @type {number}
   * @memberof V0036Node
   */
  cores?: number;
  /**
   * Default task binding
   * @type {number}
   * @memberof V0036Node
   */
  cpu_binding?: number;
  /**
   * CPU load * 100
   * @type {number}
   * @memberof V0036Node
   */
  cpu_load?: number;
  /**
   * free memory in MiB
   * @type {number}
   * @memberof V0036Node
   */
  free_memory?: number;
  /**
   * configured count of cpus running on the node
   * @type {number}
   * @memberof V0036Node
   */
  cpus?: number;
  /**
   *
   * @type {string}
   * @memberof V0036Node
   */
  features?: string;
  /**
   * list of a node\'s available features
   * @type {string}
   * @memberof V0036Node
   */
  active_features?: string;
  /**
   * list of a node\'s generic resources
   * @type {string}
   * @memberof V0036Node
   */
  gres?: string;
  /**
   * list of drained GRES
   * @type {string}
   * @memberof V0036Node
   */
  gres_drained?: string;
  /**
   * list of GRES in current use
   * @type {string}
   * @memberof V0036Node
   */
  gres_used?: string;
  /**
   * mcs label if mcs plugin in use
   * @type {string}
   * @memberof V0036Node
   */
  mcs_label?: string;
  /**
   * node name to slurm
   * @type {string}
   * @memberof V0036Node
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V0036Node
   */
  next_state_after_reboot?: string;
  /**
   * state after reboot
   * @type {string}
   * @memberof V0036Node
   */
  address?: string;
  /**
   * node\'s hostname
   * @type {string}
   * @memberof V0036Node
   */
  hostname?: string;
  /**
   * current node state
   * @type {string}
   * @memberof V0036Node
   */
  state?: string;
  /**
   * operating system
   * @type {string}
   * @memberof V0036Node
   */
  operating_system?: string;
  /**
   * User allowed to use this node
   * @type {string}
   * @memberof V0036Node
   */
  owner?: string;
  /**
   * TCP port number of the slurmd
   * @type {number}
   * @memberof V0036Node
   */
  port?: number;
  /**
   * configured MB of real memory on the node
   * @type {number}
   * @memberof V0036Node
   */
  real_memory?: number;
  /**
   * reason for node being DOWN or DRAINING
   * @type {string}
   * @memberof V0036Node
   */
  reason?: string;
  /**
   * Time stamp when reason was set
   * @type {number}
   * @memberof V0036Node
   */
  reason_changed_at?: number;
  /**
   * User that set the reason
   * @type {string}
   * @memberof V0036Node
   */
  reason_set_by_user?: string;
  /**
   * timestamp of slurmd startup
   * @type {number}
   * @memberof V0036Node
   */
  slurmd_start_time?: number;
  /**
   * total number of sockets per node
   * @type {number}
   * @memberof V0036Node
   */
  sockets?: number;
  /**
   * number of threads per core
   * @type {number}
   * @memberof V0036Node
   */
  threads?: number;
  /**
   * configured MB of total disk in TMP_FS
   * @type {number}
   * @memberof V0036Node
   */
  temporary_disk?: number;
  /**
   * arbitrary priority of node for scheduling
   * @type {number}
   * @memberof V0036Node
   */
  weight?: number;
  /**
   * TRES on node
   * @type {string}
   * @memberof V0036Node
   */
  tres?: string;
  /**
   * Slurmd version
   * @type {string}
   * @memberof V0036Node
   */
  slurmd_version?: string;
}
/**
 *
 * @export
 * @interface V0036NodeAllocation
 */
export interface V0036NodeAllocation {
  /**
   * amount of assigned job memory
   * @type {number}
   * @memberof V0036NodeAllocation
   */
  memory?: number;
  /**
   * amount of assigned job CPUs
   * @type {object}
   * @memberof V0036NodeAllocation
   */
  cpus?: object;
  /**
   * assignment status of each socket by socket id
   * @type {object}
   * @memberof V0036NodeAllocation
   */
  sockets?: object;
  /**
   * assignment status of each core by core id
   * @type {object}
   * @memberof V0036NodeAllocation
   */
  cores?: object;
}
/**
 *
 * @export
 * @interface V0036NodesResponse
 */
export interface V0036NodesResponse {
  /**
   * slurm errors
   * @type {Array<V0036Error>}
   * @memberof V0036NodesResponse
   */
  errors?: Array<V0036Error>;
  /**
   * nodes info
   * @type {Array<V0036Node>}
   * @memberof V0036NodesResponse
   */
  nodes?: Array<V0036Node>;
}
/**
 *
 * @export
 * @interface V0036Partition
 */
export interface V0036Partition {
  /**
   * partition options
   * @type {Array<string>}
   * @memberof V0036Partition
   */
  flags?: Array<string>;
  /**
   * preemption type
   * @type {string}
   * @memberof V0036Partition
   */
  preemption_mode?: string;
  /**
   * list names of allowed allocating nodes
   * @type {string}
   * @memberof V0036Partition
   */
  allowed_allocation_nodes?: string;
  /**
   * comma delimited list of accounts
   * @type {string}
   * @memberof V0036Partition
   */
  allowed_accounts?: string;
  /**
   * comma delimited list of groups
   * @type {string}
   * @memberof V0036Partition
   */
  allowed_groups?: string;
  /**
   * comma delimited list of qos
   * @type {string}
   * @memberof V0036Partition
   */
  allowed_qos?: string;
  /**
   * name of alternate partition
   * @type {string}
   * @memberof V0036Partition
   */
  alternative?: string;
  /**
   * TRES billing weights
   * @type {string}
   * @memberof V0036Partition
   */
  billing_weights?: string;
  /**
   * default MB memory per allocated CPU
   * @type {number}
   * @memberof V0036Partition
   */
  default_memory_per_cpu?: number;
  /**
   * default time limit (minutes)
   * @type {number}
   * @memberof V0036Partition
   */
  default_time_limit?: number;
  /**
   * comma delimited list of denied accounts
   * @type {string}
   * @memberof V0036Partition
   */
  denied_accounts?: string;
  /**
   * comma delimited list of denied qos
   * @type {string}
   * @memberof V0036Partition
   */
  denied_qos?: string;
  /**
   * preemption grace time (seconds)
   * @type {number}
   * @memberof V0036Partition
   */
  preemption_grace_time?: number;
  /**
   * maximum allocated CPUs per node
   * @type {number}
   * @memberof V0036Partition
   */
  maximum_cpus_per_node?: number;
  /**
   * maximum memory per allocated CPU (MiB)
   * @type {number}
   * @memberof V0036Partition
   */
  maximum_memory_per_node?: number;
  /**
   * Max nodes per job
   * @type {number}
   * @memberof V0036Partition
   */
  maximum_nodes_per_job?: number;
  /**
   * Max time limit per job
   * @type {number}
   * @memberof V0036Partition
   */
  max_time_limit?: number;
  /**
   * Min number of nodes per job
   * @type {number}
   * @memberof V0036Partition
   */
  min_nodes_per_job?: number;
  /**
   * Partition name
   * @type {string}
   * @memberof V0036Partition
   */
  name?: string;
  /**
   * list names of nodes in partition
   * @type {string}
   * @memberof V0036Partition
   */
  nodes?: string;
  /**
   * job\'s time limit can be exceeded by this number of minutes before cancellation
   * @type {number}
   * @memberof V0036Partition
   */
  over_time_limit?: number;
  /**
   * job priority weight factor
   * @type {number}
   * @memberof V0036Partition
   */
  priority_job_factor?: number;
  /**
   * tier for scheduling and preemption
   * @type {number}
   * @memberof V0036Partition
   */
  priority_tier?: number;
  /**
   * partition QOS name
   * @type {string}
   * @memberof V0036Partition
   */
  qos?: string;
  /**
   * Nodes online (ready for jobs)
   * @type {number}
   * @memberof V0036Partition
   */
  nodes_online?: number;
  /**
   * Total cpus in partition
   * @type {number}
   * @memberof V0036Partition
   */
  total_cpus?: number;
  /**
   * Total number of nodes in partition
   * @type {number}
   * @memberof V0036Partition
   */
  total_nodes?: number;
  /**
   * configured TRES in partition
   * @type {string}
   * @memberof V0036Partition
   */
  tres?: string;
}
/**
 *
 * @export
 * @interface V0036PartitionsResponse
 */
export interface V0036PartitionsResponse {
  /**
   * slurm errors
   * @type {Array<V0036Error>}
   * @memberof V0036PartitionsResponse
   */
  errors?: Array<V0036Error>;
  /**
   * partition info
   * @type {Array<V0036Partition>}
   * @memberof V0036PartitionsResponse
   */
  partitions?: Array<V0036Partition>;
}
/**
 *
 * @export
 * @interface V0036Ping
 */
export interface V0036Ping {
  /**
   * slurm controller hostname
   * @type {string}
   * @memberof V0036Ping
   */
  hostname?: string;
  /**
   * slurm controller host up
   * @type {string}
   * @memberof V0036Ping
   */
  ping?: V0036PingPingEnum;
  /**
   * slurm controller mode
   * @type {string}
   * @memberof V0036Ping
   */
  mode?: string;
  /**
   * slurm controller status
   * @type {number}
   * @memberof V0036Ping
   */
  status?: number;
}

/**
 * @export
 * @enum {string}
 */
export enum V0036PingPingEnum {
  Up = 'UP',
  Down = 'DOWN',
}

/**
 *
 * @export
 * @interface V0036Pings
 */
export interface V0036Pings {
  /**
   * slurm errors
   * @type {Array<V0036Error>}
   * @memberof V0036Pings
   */
  errors?: Array<V0036Error>;
  /**
   * slurm controller pings
   * @type {Array<V0036Ping>}
   * @memberof V0036Pings
   */
  pings?: Array<V0036Ping>;
}
/**
 * POSIX signal name
 * @export
 * @enum {string}
 */

export enum V0036Signal {
  Hup = 'HUP',
  Int = 'INT',
  Quit = 'QUIT',
  Abrt = 'ABRT',
  Kill = 'KILL',
  Alrm = 'ALRM',
  Term = 'TERM',
  Usr1 = 'USR1',
  Usr2 = 'USR2',
  Urg = 'URG',
  Cont = 'CONT',
  Stop = 'STOP',
  Tstp = 'TSTP',
  Ttin = 'TTIN',
  Ttou = 'TTOU',
}

/**
 *
 * @export
 * @interface V0037Diag
 */
export interface V0037Diag {
  /**
   * slurm errors
   * @type {Array<V0037Error>}
   * @memberof V0037Diag
   */
  errors?: Array<V0037Error>;
  /**
   *
   * @type {V0037DiagStatistics}
   * @memberof V0037Diag
   */
  statistics?: V0037DiagStatistics;
}
/**
 * Slurm statistics
 * @export
 * @interface V0037DiagStatistics
 */
export interface V0037DiagStatistics {
  /**
   * partition records packed
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  parts_packed?: number;
  /**
   * generation time
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  req_time?: number;
  /**
   * data since
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  req_time_start?: number;
  /**
   * Server thread count
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  server_thread_count?: number;
  /**
   * Agent queue size
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  agent_queue_size?: number;
  /**
   * Agent count
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  agent_count?: number;
  /**
   * Agent thread count
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  agent_thread_count?: number;
  /**
   * DBD Agent queue size
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  dbd_agent_queue_size?: number;
  /**
   * Latency for 1000 calls to gettimeofday()
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  gettimeofday_latency?: number;
  /**
   * Main Schedule max cycle
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  schedule_cycle_max?: number;
  /**
   * Main Schedule last cycle
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  schedule_cycle_last?: number;
  /**
   * Main Schedule cycle iterations
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  schedule_cycle_total?: number;
  /**
   * Average time for Schedule Max cycle
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  schedule_cycle_mean?: number;
  /**
   * Average depth for Schedule Max cycle
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  schedule_cycle_mean_depth?: number;
  /**
   * Main Schedule Cycles per minute
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  schedule_cycle_per_minute?: number;
  /**
   * Main Schedule Last queue length
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  schedule_queue_length?: number;
  /**
   * Job submitted
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  jobs_submitted?: number;
  /**
   * Job started
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  jobs_started?: number;
  /**
   * Job completed
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  jobs_completed?: number;
  /**
   * Job cancelled
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  jobs_canceled?: number;
  /**
   * Job failed
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  jobs_failed?: number;
  /**
   * Job pending
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  jobs_pending?: number;
  /**
   * Job running
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  jobs_running?: number;
  /**
   * Job states timestamp
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  job_states_ts?: number;
  /**
   * Total backfilled jobs (since last slurm start)
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  bf_backfilled_jobs?: number;
  /**
   * Total backfilled jobs (since last stats cycle start)
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  bf_last_backfilled_jobs?: number;
  /**
   * Total backfilled heterogeneous job components
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  bf_backfilled_het_jobs?: number;
  /**
   * Backfill Schedule Total cycles
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  bf_cycle_counter?: number;
  /**
   * Backfill Schedule Mean cycle
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  bf_cycle_mean?: number;
  /**
   * Backfill Schedule Max cycle time
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  bf_cycle_max?: number;
  /**
   * Backfill Schedule Last depth cycle
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  bf_last_depth?: number;
  /**
   * Backfill Schedule Mean cycle (try sched)
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  bf_last_depth_try?: number;
  /**
   * Backfill Schedule Depth Mean
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  bf_depth_mean?: number;
  /**
   * Backfill Schedule Depth Mean (try sched)
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  bf_depth_mean_try?: number;
  /**
   * Backfill Schedule Last cycle time
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  bf_cycle_last?: number;
  /**
   * Backfill Schedule Last queue length
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  bf_queue_len?: number;
  /**
   * Backfill Schedule Mean queue length
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  bf_queue_len_mean?: number;
  /**
   * Last cycle timestamp
   * @type {number}
   * @memberof V0037DiagStatistics
   */
  bf_when_last_cycle?: number;
  /**
   * Backfill Schedule currently active
   * @type {boolean}
   * @memberof V0037DiagStatistics
   */
  bf_active?: boolean;
}
/**
 *
 * @export
 * @interface V0037Error
 */
export interface V0037Error {
  /**
   * error message
   * @type {string}
   * @memberof V0037Error
   */
  error?: string;
  /**
   * error number
   * @type {number}
   * @memberof V0037Error
   */
  errno?: number;
}
/**
 *
 * @export
 * @interface V0037JobProperties
 */
export interface V0037JobProperties {
  /**
   * Charge resources used by this job to specified account.
   * @type {string}
   * @memberof V0037JobProperties
   */
  account?: string;
  /**
   * Define the job accounting and profiling sampling intervals.
   * @type {string}
   * @memberof V0037JobProperties
   */
  account_gather_freqency?: string;
  /**
   * Arguments to the script.
   * @type {Array<string>}
   * @memberof V0037JobProperties
   */
  argv?: Array<string>;
  /**
   * Submit a job array, multiple jobs to be executed with identical parameters. The indexes specification identifies what array index values should be used.
   * @type {string}
   * @memberof V0037JobProperties
   */
  array?: string;
  /**
   * features required for batch script\'s node
   * @type {string}
   * @memberof V0037JobProperties
   */
  batch_features?: string;
  /**
   * Submit the batch script to the Slurm controller immediately, like normal, but tell the controller to defer the allocation of the job until the specified time.
   * @type {number}
   * @memberof V0037JobProperties
   */
  begin_time?: number;
  /**
   * Burst buffer specification.
   * @type {string}
   * @memberof V0037JobProperties
   */
  burst_buffer?: string;
  /**
   * Specifies features that a federated cluster must have to have a sibling job submitted to it.
   * @type {string}
   * @memberof V0037JobProperties
   */
  cluster_constraints?: string;
  /**
   * An arbitrary comment.
   * @type {string}
   * @memberof V0037JobProperties
   */
  comment?: string;
  /**
   * node features required by job.
   * @type {string}
   * @memberof V0037JobProperties
   */
  constraints?: string;
  /**
   * Count of specialized threads per node reserved by the job for system operations and not used by the application.
   * @type {number}
   * @memberof V0037JobProperties
   */
  core_specification?: number;
  /**
   * Restrict node selection to nodes with at least the specified number of cores per socket.
   * @type {number}
   * @memberof V0037JobProperties
   */
  cores_per_socket?: number;
  /**
   * Cpu binding
   * @type {string}
   * @memberof V0037JobProperties
   */
  cpu_binding?: string;
  /**
   * Cpu binding hint
   * @type {string}
   * @memberof V0037JobProperties
   */
  cpu_binding_hint?: string;
  /**
   * Request that job steps initiated by srun commands inside this sbatch script be run at some requested frequency if possible, on the CPUs selected for the step on the compute node(s).
   * @type {string}
   * @memberof V0037JobProperties
   */
  cpu_frequency?: string;
  /**
   * Number of CPUs requested per allocated GPU.
   * @type {string}
   * @memberof V0037JobProperties
   */
  cpus_per_gpu?: string;
  /**
   * Advise the Slurm controller that ensuing job steps will require ncpus number of processors per task.
   * @type {number}
   * @memberof V0037JobProperties
   */
  cpus_per_task?: number;
  /**
   * Instruct Slurm to connect the batch script\'s standard output directly to the file name.
   * @type {string}
   * @memberof V0037JobProperties
   */
  current_working_directory?: string;
  /**
   * Remove the job if no ending is possible before this deadline (start > (deadline - time[-min])).
   * @type {string}
   * @memberof V0037JobProperties
   */
  deadline?: string;
  /**
   * Do not reboot nodes in order to satisfied this job\'s feature specification if the job has been eligible to run for less than this time period.
   * @type {number}
   * @memberof V0037JobProperties
   */
  delay_boot?: number;
  /**
   * Defer the start of this job until the specified dependencies have been satisfied completed.
   * @type {string}
   * @memberof V0037JobProperties
   */
  dependency?: string;
  /**
   * Specify alternate distribution methods for remote processes.
   * @type {string}
   * @memberof V0037JobProperties
   */
  distribution?: string;
  /**
   * Dictionary of environment entries.
   * @type {object}
   * @memberof V0037JobProperties
   */
  environment: object;
  /**
   * The job allocation can share nodes just other users with the \"user\" option or with the \"mcs\" option).
   * @type {string}
   * @memberof V0037JobProperties
   */
  exclusive?: V0037JobPropertiesExclusiveEnum;
  /**
   * Load new login environment for user on job node.
   * @type {boolean}
   * @memberof V0037JobProperties
   */
  get_user_environment?: boolean;
  /**
   * Specifies a comma delimited list of generic consumable resources.
   * @type {string}
   * @memberof V0037JobProperties
   */
  gres?: string;
  /**
   * Specify generic resource task binding options.
   * @type {string}
   * @memberof V0037JobProperties
   */
  gres_flags?: V0037JobPropertiesGresFlagsEnum;
  /**
   * Requested binding of tasks to GPU.
   * @type {string}
   * @memberof V0037JobProperties
   */
  gpu_binding?: string;
  /**
   * Requested GPU frequency.
   * @type {string}
   * @memberof V0037JobProperties
   */
  gpu_frequency?: string;
  /**
   * GPUs per job.
   * @type {string}
   * @memberof V0037JobProperties
   */
  gpus?: string;
  /**
   * GPUs per node.
   * @type {string}
   * @memberof V0037JobProperties
   */
  gpus_per_node?: string;
  /**
   * GPUs per socket.
   * @type {string}
   * @memberof V0037JobProperties
   */
  gpus_per_socket?: string;
  /**
   * GPUs per task.
   * @type {string}
   * @memberof V0037JobProperties
   */
  gpus_per_task?: string;
  /**
   * Specify the job is to be submitted in a held state (priority of zero).
   * @type {boolean}
   * @memberof V0037JobProperties
   */
  hold?: boolean;
  /**
   * If a job has an invalid dependency, then Slurm is to terminate it.
   * @type {boolean}
   * @memberof V0037JobProperties
   */
  kill_on_invalid_dependency?: boolean;
  /**
   * Specification of licenses (or other resources available on all nodes of the cluster) which must be allocated to this job.
   * @type {string}
   * @memberof V0037JobProperties
   */
  licenses?: string;
  /**
   * Notify user by email when certain event types occur.
   * @type {string}
   * @memberof V0037JobProperties
   */
  mail_type?: string;
  /**
   * User to receive email notification of state changes as defined by mail_type.
   * @type {string}
   * @memberof V0037JobProperties
   */
  mail_user?: string;
  /**
   * This parameter is a group among the groups of the user.
   * @type {string}
   * @memberof V0037JobProperties
   */
  mcs_label?: string;
  /**
   * Bind tasks to memory.
   * @type {string}
   * @memberof V0037JobProperties
   */
  memory_binding?: string;
  /**
   * Minimum real memory per cpu (MB).
   * @type {number}
   * @memberof V0037JobProperties
   */
  memory_per_cpu?: number;
  /**
   * Minimum memory required per allocated GPU.
   * @type {number}
   * @memberof V0037JobProperties
   */
  memory_per_gpu?: number;
  /**
   * Minimum real memory per node (MB).
   * @type {number}
   * @memberof V0037JobProperties
   */
  memory_per_node?: number;
  /**
   * Minimum number of CPUs per node.
   * @type {number}
   * @memberof V0037JobProperties
   */
  minimum_cpus_per_node?: number;
  /**
   * If a range of node counts is given, prefer the smaller count.
   * @type {boolean}
   * @memberof V0037JobProperties
   */
  minimum_nodes?: boolean;
  /**
   * Specify a name for the job allocation.
   * @type {string}
   * @memberof V0037JobProperties
   */
  name?: string;
  /**
   * Run the job with an adjusted scheduling priority within Slurm.
   * @type {string}
   * @memberof V0037JobProperties
   */
  nice?: string;
  /**
   * Do not automatically terminate a job if one of the nodes it has been allocated fails.
   * @type {boolean}
   * @memberof V0037JobProperties
   */
  no_kill?: boolean;
  /**
   * Request that a minimum of minnodes nodes and a maximum node count.
   * @type {Array<number>}
   * @memberof V0037JobProperties
   */
  nodes?: Array<number>;
  /**
   * Open the output and error files using append or truncate mode as specified.
   * @type {string}
   * @memberof V0037JobProperties
   */
  open_mode?: V0037JobPropertiesOpenModeEnum;
  /**
   * Request a specific partition for the resource allocation.
   * @type {string}
   * @memberof V0037JobProperties
   */
  partition?: string;
  /**
   * Request a specific job priority.
   * @type {string}
   * @memberof V0037JobProperties
   */
  priority?: string;
  /**
   * Request a quality of service for the job.
   * @type {string}
   * @memberof V0037JobProperties
   */
  qos?: string;
  /**
   * Specifies that the batch job should eligible to being requeue.
   * @type {boolean}
   * @memberof V0037JobProperties
   */
  requeue?: boolean;
  /**
   * Allocate resources for the job from the named reservation.
   * @type {string}
   * @memberof V0037JobProperties
   */
  reservation?: string;
  /**
   * When a job is within sig_time seconds of its end time, send it the signal sig_num.
   * @type {string}
   * @memberof V0037JobProperties
   */
  signal?: string;
  /**
   * Restrict node selection to nodes with at least the specified number of sockets.
   * @type {number}
   * @memberof V0037JobProperties
   */
  sockets_per_node?: number;
  /**
   * Spread the job allocation over as many nodes as possible and attempt to evenly distribute tasks across the allocated nodes.
   * @type {boolean}
   * @memberof V0037JobProperties
   */
  spread_job?: boolean;
  /**
   * Instruct Slurm to connect the batch script\'s standard error directly to the file name.
   * @type {string}
   * @memberof V0037JobProperties
   */
  standard_error?: string;
  /**
   * Instruct Slurm to connect the batch script\'s standard input directly to the file name specified.
   * @type {string}
   * @memberof V0037JobProperties
   */
  standard_input?: string;
  /**
   * Instruct Slurm to connect the batch script\'s standard output directly to the file name.
   * @type {string}
   * @memberof V0037JobProperties
   */
  standard_output?: string;
  /**
   * Advises the Slurm controller that job steps run within the allocation will launch a maximum of number tasks and to provide for sufficient resources.
   * @type {number}
   * @memberof V0037JobProperties
   */
  tasks?: number;
  /**
   * Request the maximum ntasks be invoked on each core.
   * @type {number}
   * @memberof V0037JobProperties
   */
  tasks_per_core?: number;
  /**
   * Request the maximum ntasks be invoked on each node.
   * @type {number}
   * @memberof V0037JobProperties
   */
  tasks_per_node?: number;
  /**
   * Request the maximum ntasks be invoked on each socket.
   * @type {number}
   * @memberof V0037JobProperties
   */
  tasks_per_socket?: number;
  /**
   * Count of specialized threads per node reserved by the job for system operations and not used by the application.
   * @type {number}
   * @memberof V0037JobProperties
   */
  thread_specification?: number;
  /**
   * Restrict node selection to nodes with at least the specified number of threads per core.
   * @type {number}
   * @memberof V0037JobProperties
   */
  threads_per_core?: number;
  /**
   * Step time limit.
   * @type {number}
   * @memberof V0037JobProperties
   */
  time_limit?: number;
  /**
   * Minimum run time in minutes.
   * @type {number}
   * @memberof V0037JobProperties
   */
  time_minimum?: number;
  /**
   * Do not begin execution until all nodes are ready for use.
   * @type {boolean}
   * @memberof V0037JobProperties
   */
  wait_all_nodes?: boolean;
  /**
   * Specify wckey to be used with job.
   * @type {string}
   * @memberof V0037JobProperties
   */
  wckey?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum V0037JobPropertiesExclusiveEnum {
  User = 'user',
  Mcs = 'mcs',
  True = 'true',
  False = 'false',
}
/**
 * @export
 * @enum {string}
 */
export enum V0037JobPropertiesGresFlagsEnum {
  DisableBinding = 'disable-binding',
  EnforceBinding = 'enforce-binding',
}
/**
 * @export
 * @enum {string}
 */
export enum V0037JobPropertiesOpenModeEnum {
  Append = 'append',
  Truncate = 'truncate',
}

/**
 *
 * @export
 * @interface V0037JobResources
 */
export interface V0037JobResources {
  /**
   * list of assigned job nodes
   * @type {string}
   * @memberof V0037JobResources
   */
  nodes?: string;
  /**
   * number of assigned job cpus
   * @type {number}
   * @memberof V0037JobResources
   */
  allocated_cpus?: number;
  /**
   * number of assigned job hosts
   * @type {number}
   * @memberof V0037JobResources
   */
  allocated_hosts?: number;
  /**
   * node allocations
   * @type {Array<V0037NodeAllocation>}
   * @memberof V0037JobResources
   */
  allocated_nodes?: Array<V0037NodeAllocation>;
}
/**
 *
 * @export
 * @interface V0037JobResponseProperties
 */
export interface V0037JobResponseProperties {
  /**
   * Charge resources used by this job to specified account
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  account?: string;
  /**
   * time job is eligible for running
   * @type {number}
   * @memberof V0037JobResponseProperties
   */
  accrue_time?: number;
  /**
   * administrator\'s arbitrary comment
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  admin_comment?: string;
  /**
   * job_id of a job array or 0 if N/A
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  array_job_id?: string;
  /**
   * task_id of a job array
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  array_task_id?: string;
  /**
   * Maximum number of running array tasks
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  array_max_tasks?: string;
  /**
   * string expression of task IDs in this record
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  array_task_string?: string;
  /**
   * association id for job
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  association_id?: string;
  /**
   * features required for batch script\'s node
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  batch_features?: string;
  /**
   * if batch: queued job with script
   * @type {boolean}
   * @memberof V0037JobResponseProperties
   */
  batch_flag?: boolean;
  /**
   * name of host running batch script
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  batch_host?: string;
  /**
   * Job flags
   * @type {Array<string>}
   * @memberof V0037JobResponseProperties
   */
  flags?: Array<string>;
  /**
   * burst buffer specifications
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  burst_buffer?: string;
  /**
   * burst buffer state info
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  burst_buffer_state?: string;
  /**
   * name of cluster that the job is on
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  cluster?: string;
  /**
   * comma separated list of required cluster features
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  cluster_features?: string;
  /**
   * command to be executed
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  command?: string;
  /**
   * arbitrary comment
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  comment?: string;
  /**
   * job requires contiguous nodes
   * @type {boolean}
   * @memberof V0037JobResponseProperties
   */
  contiguous?: boolean;
  /**
   * specialized core count
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  core_spec?: string;
  /**
   * specialized thread count
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  thread_spec?: string;
  /**
   * cores per socket required by job
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  cores_per_socket?: string;
  /**
   * billable TRES
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  billable_tres?: string;
  /**
   * number of processors required for each task
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  cpus_per_task?: string;
  /**
   * Minimum cpu frequency
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  cpu_frequency_minimum?: string;
  /**
   * Maximum cpu frequency
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  cpu_frequency_maximum?: string;
  /**
   * cpu frequency governor
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  cpu_frequency_governor?: string;
  /**
   * semicolon delimited list of TRES=# values
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  cpus_per_tres?: string;
  /**
   * job start deadline
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  deadline?: string;
  /**
   * command to be executed
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  delay_boot?: string;
  /**
   * synchronize job execution with other jobs
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  dependency?: string;
  /**
   * highest exit code of all job steps
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  derived_exit_code?: string;
  /**
   * time job is eligible for running
   * @type {number}
   * @memberof V0037JobResponseProperties
   */
  eligible_time?: number;
  /**
   * time of termination, actual or expected
   * @type {number}
   * @memberof V0037JobResponseProperties
   */
  end_time?: number;
  /**
   * comma separated list of excluded nodes
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  excluded_nodes?: string;
  /**
   * exit code for job
   * @type {number}
   * @memberof V0037JobResponseProperties
   */
  exit_code?: number;
  /**
   * comma separated list of required features
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  features?: string;
  /**
   * Origin cluster\'s name
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  federation_origin?: string;
  /**
   * string of active sibling names
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  federation_siblings_active?: string;
  /**
   * string of viable sibling names
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  federation_siblings_viable?: string;
  /**
   * Job flags
   * @type {Array<string>}
   * @memberof V0037JobResponseProperties
   */
  gres_detail?: Array<string>;
  /**
   * group job submitted as
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  group_id?: string;
  /**
   * job ID
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  job_id?: string;
  /**
   *
   * @type {V0037JobResources}
   * @memberof V0037JobResponseProperties
   */
  job_resources?: V0037JobResources;
  /**
   * state of the job
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  job_state?: string;
  /**
   * last time job was evaluated for scheduling
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  last_sched_evaluation?: string;
  /**
   * licenses required by the job
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  licenses?: string;
  /**
   * maximum number of cpus usable by job
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  max_cpus?: string;
  /**
   * maximum number of nodes usable by job
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  max_nodes?: string;
  /**
   * mcs_label if mcs plugin in use
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  mcs_label?: string;
  /**
   * semicolon delimited list of TRES=# values
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  memory_per_tres?: string;
  /**
   * name of the job
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  name?: string;
  /**
   * list of nodes allocated to job
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  nodes?: string;
  /**
   * requested priority change
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  nice?: string;
  /**
   * number of tasks to invoke on each core
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  tasks_per_core?: string;
  /**
   * number of tasks to invoke on each socket
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  tasks_per_socket?: string;
  /**
   * number of tasks to invoke on each board
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  tasks_per_board?: string;
  /**
   * minimum number of cpus required by job
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  cpus?: string;
  /**
   * minimum number of nodes required by job
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  node_count?: string;
  /**
   * requested task count
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  tasks?: string;
  /**
   * job ID of hetjob leader
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  het_job_id?: string;
  /**
   * job IDs for all components
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  het_job_id_set?: string;
  /**
   * HetJob component offset from leader
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  het_job_offset?: string;
  /**
   * name of assigned partition
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  partition?: string;
  /**
   * minimum real memory per node
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  memory_per_node?: string;
  /**
   * minimum real memory per cpu
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  memory_per_cpu?: string;
  /**
   * minimum # CPUs per node
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  minimum_cpus_per_node?: string;
  /**
   * minimum tmp disk per node
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  minimum_tmp_disk_per_node?: string;
  /**
   * preemption signal time
   * @type {number}
   * @memberof V0037JobResponseProperties
   */
  preempt_time?: number;
  /**
   * time job ran prior to last suspend
   * @type {number}
   * @memberof V0037JobResponseProperties
   */
  pre_sus_time?: number;
  /**
   * relative priority of the job
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  priority?: string;
  /**
   * Job profiling requested
   * @type {Array<string>}
   * @memberof V0037JobResponseProperties
   */
  profile?: Array<string>;
  /**
   * Quality of Service
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  qos?: string;
  /**
   * node reboot requested before start
   * @type {boolean}
   * @memberof V0037JobResponseProperties
   */
  reboot?: boolean;
  /**
   * comma separated list of required nodes
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  required_nodes?: string;
  /**
   * enable or disable job requeue option
   * @type {boolean}
   * @memberof V0037JobResponseProperties
   */
  requeue?: boolean;
  /**
   * time of latest size change
   * @type {number}
   * @memberof V0037JobResponseProperties
   */
  resize_time?: number;
  /**
   * count of job restarts
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  restart_cnt?: string;
  /**
   * reservation name
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  resv_name?: string;
  /**
   * type and if job can share nodes with other jobs
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  shared?: string;
  /**
   * details requested
   * @type {Array<string>}
   * @memberof V0037JobResponseProperties
   */
  show_flags?: Array<string>;
  /**
   * sockets per board required by job
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  sockets_per_board?: string;
  /**
   * sockets per node required by job
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  sockets_per_node?: string;
  /**
   * time execution begins, actual or expected
   * @type {number}
   * @memberof V0037JobResponseProperties
   */
  start_time?: number;
  /**
   * optional details for state_reason
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  state_description?: string;
  /**
   * reason job still pending or failed
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  state_reason?: string;
  /**
   * pathname of job\'s stderr file
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  standard_error?: string;
  /**
   * pathname of job\'s stdin file
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  standard_input?: string;
  /**
   * pathname of job\'s stdout file
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  standard_output?: string;
  /**
   * time of job submission
   * @type {number}
   * @memberof V0037JobResponseProperties
   */
  submit_time?: number;
  /**
   * time job last suspended or resumed
   * @type {number}
   * @memberof V0037JobResponseProperties
   */
  suspend_time?: number;
  /**
   * slurmctld\'s arbitrary comment
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  system_comment?: string;
  /**
   * maximum run time in minutes
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  time_limit?: string;
  /**
   * minimum run time in minutes
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  time_minimum?: string;
  /**
   * threads per core required by job
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  threads_per_core?: string;
  /**
   * Task to TRES binding directives
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  tres_bind?: string;
  /**
   * TRES frequency directives
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  tres_freq?: string;
  /**
   * semicolon delimited list of TRES=# values
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  tres_per_job?: string;
  /**
   * semicolon delimited list of TRES=# values
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  tres_per_node?: string;
  /**
   * semicolon delimited list of TRES=# values
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  tres_per_socket?: string;
  /**
   * semicolon delimited list of TRES=# values
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  tres_per_task?: string;
  /**
   * tres reqeusted in the job
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  tres_req_str?: string;
  /**
   * tres used in the job
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  tres_alloc_str?: string;
  /**
   * user id the job runs as
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  user_id?: string;
  /**
   * user the job runs as
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  user_name?: string;
  /**
   * wckey for job
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  wckey?: string;
  /**
   * pathname of working directory
   * @type {string}
   * @memberof V0037JobResponseProperties
   */
  current_working_directory?: string;
}
/**
 *
 * @export
 * @interface V0037JobSubmission
 */
export interface V0037JobSubmission {
  /**
   * Executable script (full contents) to run in batch step
   * @type {string}
   * @memberof V0037JobSubmission
   */
  script: string;
  /**
   *
   * @type {V0037JobProperties}
   * @memberof V0037JobSubmission
   */
  job?: V0037JobProperties;
  /**
   * Properties of an HetJob
   * @type {Array<V0037JobProperties>}
   * @memberof V0037JobSubmission
   */
  jobs?: Array<V0037JobProperties>;
}
/**
 *
 * @export
 * @interface V0037JobSubmissionResponse
 */
export interface V0037JobSubmissionResponse {
  /**
   * slurm errors
   * @type {Array<V0037Error>}
   * @memberof V0037JobSubmissionResponse
   */
  errors?: Array<V0037Error>;
  /**
   * new job ID
   * @type {number}
   * @memberof V0037JobSubmissionResponse
   */
  job_id?: number;
  /**
   * new job step ID
   * @type {string}
   * @memberof V0037JobSubmissionResponse
   */
  step_id?: string;
  /**
   * Message to user from job_submit plugin
   * @type {string}
   * @memberof V0037JobSubmissionResponse
   */
  job_submit_user_msg?: string;
}
/**
 *
 * @export
 * @interface V0037JobsResponse
 */
export interface V0037JobsResponse {
  /**
   * slurm errors
   * @type {Array<V0037Error>}
   * @memberof V0037JobsResponse
   */
  errors?: Array<V0037Error>;
  /**
   * job descriptions
   * @type {Array<V0037JobResponseProperties>}
   * @memberof V0037JobsResponse
   */
  jobs?: Array<V0037JobResponseProperties>;
}
/**
 *
 * @export
 * @interface V0037Node
 */
export interface V0037Node {
  /**
   * computer architecture
   * @type {string}
   * @memberof V0037Node
   */
  architecture?: string;
  /**
   * BcastAddr
   * @type {string}
   * @memberof V0037Node
   */
  burstbuffer_network_address?: string;
  /**
   * total number of boards per node
   * @type {number}
   * @memberof V0037Node
   */
  boards?: number;
  /**
   * timestamp of node boot
   * @type {number}
   * @memberof V0037Node
   */
  boot_time?: number;
  /**
   * number of cores per socket
   * @type {number}
   * @memberof V0037Node
   */
  cores?: number;
  /**
   * Default task binding
   * @type {number}
   * @memberof V0037Node
   */
  cpu_binding?: number;
  /**
   * CPU load * 100
   * @type {number}
   * @memberof V0037Node
   */
  cpu_load?: number;
  /**
   * free memory in MiB
   * @type {number}
   * @memberof V0037Node
   */
  free_memory?: number;
  /**
   * configured count of cpus running on the node
   * @type {number}
   * @memberof V0037Node
   */
  cpus?: number;
  /**
   *
   * @type {string}
   * @memberof V0037Node
   */
  features?: string;
  /**
   * list of a node\'s available features
   * @type {string}
   * @memberof V0037Node
   */
  active_features?: string;
  /**
   * list of a node\'s generic resources
   * @type {string}
   * @memberof V0037Node
   */
  gres?: string;
  /**
   * list of drained GRES
   * @type {string}
   * @memberof V0037Node
   */
  gres_drained?: string;
  /**
   * list of GRES in current use
   * @type {string}
   * @memberof V0037Node
   */
  gres_used?: string;
  /**
   * mcs label if mcs plugin in use
   * @type {string}
   * @memberof V0037Node
   */
  mcs_label?: string;
  /**
   * node name to slurm
   * @type {string}
   * @memberof V0037Node
   */
  name?: string;
  /**
   * state after reboot
   * @type {string}
   * @memberof V0037Node
   */
  next_state_after_reboot?: string;
  /**
   * node state flags
   * @type {Array<string>}
   * @memberof V0037Node
   */
  next_state_after_reboot_flags?: Array<string>;
  /**
   * state after reboot
   * @type {string}
   * @memberof V0037Node
   */
  address?: string;
  /**
   * node\'s hostname
   * @type {string}
   * @memberof V0037Node
   */
  hostname?: string;
  /**
   * current node state
   * @type {string}
   * @memberof V0037Node
   */
  state?: string;
  /**
   * node state flags
   * @type {Array<string>}
   * @memberof V0037Node
   */
  state_flags?: Array<string>;
  /**
   * operating system
   * @type {string}
   * @memberof V0037Node
   */
  operating_system?: string;
  /**
   * User allowed to use this node
   * @type {string}
   * @memberof V0037Node
   */
  owner?: string;
  /**
   * assigned partitions
   * @type {Array<string>}
   * @memberof V0037Node
   */
  partitions?: Array<string>;
  /**
   * TCP port number of the slurmd
   * @type {number}
   * @memberof V0037Node
   */
  port?: number;
  /**
   * configured MB of real memory on the node
   * @type {number}
   * @memberof V0037Node
   */
  real_memory?: number;
  /**
   * reason for node being DOWN or DRAINING
   * @type {string}
   * @memberof V0037Node
   */
  reason?: string;
  /**
   * Time stamp when reason was set
   * @type {number}
   * @memberof V0037Node
   */
  reason_changed_at?: number;
  /**
   * User that set the reason
   * @type {string}
   * @memberof V0037Node
   */
  reason_set_by_user?: string;
  /**
   * timestamp of slurmd startup
   * @type {number}
   * @memberof V0037Node
   */
  slurmd_start_time?: number;
  /**
   * total number of sockets per node
   * @type {number}
   * @memberof V0037Node
   */
  sockets?: number;
  /**
   * number of threads per core
   * @type {number}
   * @memberof V0037Node
   */
  threads?: number;
  /**
   * configured MB of total disk in TMP_FS
   * @type {number}
   * @memberof V0037Node
   */
  temporary_disk?: number;
  /**
   * arbitrary priority of node for scheduling
   * @type {number}
   * @memberof V0037Node
   */
  weight?: number;
  /**
   * TRES on node
   * @type {string}
   * @memberof V0037Node
   */
  tres?: string;
  /**
   * TRES used on node
   * @type {string}
   * @memberof V0037Node
   */
  tres_used?: string;
  /**
   * TRES weight used on node
   * @type {number}
   * @memberof V0037Node
   */
  tres_weighted?: number;
  /**
   * Slurmd version
   * @type {string}
   * @memberof V0037Node
   */
  slurmd_version?: string;
  /**
   * Allocated CPUs
   * @type {number}
   * @memberof V0037Node
   */
  alloc_cpus?: number;
  /**
   * Idle CPUs
   * @type {number}
   * @memberof V0037Node
   */
  idle_cpus?: number;
  /**
   * Allocated memory (MB)
   * @type {number}
   * @memberof V0037Node
   */
  alloc_memory?: number;
}
/**
 *
 * @export
 * @interface V0037NodeAllocation
 */
export interface V0037NodeAllocation {
  /**
   * amount of assigned job memory
   * @type {number}
   * @memberof V0037NodeAllocation
   */
  memory?: number;
  /**
   * amount of assigned job CPUs
   * @type {object}
   * @memberof V0037NodeAllocation
   */
  cpus?: object;
  /**
   * assignment status of each socket by socket id
   * @type {object}
   * @memberof V0037NodeAllocation
   */
  sockets?: object;
  /**
   * assignment status of each core by core id
   * @type {object}
   * @memberof V0037NodeAllocation
   */
  cores?: object;
}
/**
 *
 * @export
 * @interface V0037NodesResponse
 */
export interface V0037NodesResponse {
  /**
   * slurm errors
   * @type {Array<V0037Error>}
   * @memberof V0037NodesResponse
   */
  errors?: Array<V0037Error>;
  /**
   * nodes info
   * @type {Array<V0037Node>}
   * @memberof V0037NodesResponse
   */
  nodes?: Array<V0037Node>;
}
/**
 *
 * @export
 * @interface V0037Partition
 */
export interface V0037Partition {
  /**
   * partition options
   * @type {Array<string>}
   * @memberof V0037Partition
   */
  flags?: Array<string>;
  /**
   * preemption type
   * @type {Array<string>}
   * @memberof V0037Partition
   */
  preemption_mode?: Array<string>;
  /**
   * list names of allowed allocating nodes
   * @type {string}
   * @memberof V0037Partition
   */
  allowed_allocation_nodes?: string;
  /**
   * comma delimited list of accounts
   * @type {string}
   * @memberof V0037Partition
   */
  allowed_accounts?: string;
  /**
   * comma delimited list of groups
   * @type {string}
   * @memberof V0037Partition
   */
  allowed_groups?: string;
  /**
   * comma delimited list of qos
   * @type {string}
   * @memberof V0037Partition
   */
  allowed_qos?: string;
  /**
   * name of alternate partition
   * @type {string}
   * @memberof V0037Partition
   */
  alternative?: string;
  /**
   * TRES billing weights
   * @type {string}
   * @memberof V0037Partition
   */
  billing_weights?: string;
  /**
   * default MB memory per allocated CPU
   * @type {number}
   * @memberof V0037Partition
   */
  default_memory_per_cpu?: number;
  /**
   * default time limit (minutes)
   * @type {number}
   * @memberof V0037Partition
   */
  default_time_limit?: number;
  /**
   * comma delimited list of denied accounts
   * @type {string}
   * @memberof V0037Partition
   */
  denied_accounts?: string;
  /**
   * comma delimited list of denied qos
   * @type {string}
   * @memberof V0037Partition
   */
  denied_qos?: string;
  /**
   * preemption grace time (seconds)
   * @type {number}
   * @memberof V0037Partition
   */
  preemption_grace_time?: number;
  /**
   * maximum allocated CPUs per node
   * @type {number}
   * @memberof V0037Partition
   */
  maximum_cpus_per_node?: number;
  /**
   * maximum memory per allocated CPU (MiB)
   * @type {number}
   * @memberof V0037Partition
   */
  maximum_memory_per_node?: number;
  /**
   * Max nodes per job
   * @type {number}
   * @memberof V0037Partition
   */
  maximum_nodes_per_job?: number;
  /**
   * Max time limit per job
   * @type {number}
   * @memberof V0037Partition
   */
  max_time_limit?: number;
  /**
   * Min number of nodes per job
   * @type {number}
   * @memberof V0037Partition
   */
  min_nodes_per_job?: number;
  /**
   * Partition name
   * @type {string}
   * @memberof V0037Partition
   */
  name?: string;
  /**
   * list names of nodes in partition
   * @type {string}
   * @memberof V0037Partition
   */
  nodes?: string;
  /**
   * job\'s time limit can be exceeded by this number of minutes before cancellation
   * @type {number}
   * @memberof V0037Partition
   */
  over_time_limit?: number;
  /**
   * job priority weight factor
   * @type {number}
   * @memberof V0037Partition
   */
  priority_job_factor?: number;
  /**
   * tier for scheduling and preemption
   * @type {number}
   * @memberof V0037Partition
   */
  priority_tier?: number;
  /**
   * partition QOS name
   * @type {string}
   * @memberof V0037Partition
   */
  qos?: string;
  /**
   * Partition state
   * @type {string}
   * @memberof V0037Partition
   */
  state?: string;
  /**
   * Total cpus in partition
   * @type {number}
   * @memberof V0037Partition
   */
  total_cpus?: number;
  /**
   * Total number of nodes in partition
   * @type {number}
   * @memberof V0037Partition
   */
  total_nodes?: number;
  /**
   * configured TRES in partition
   * @type {string}
   * @memberof V0037Partition
   */
  tres?: string;
}
/**
 *
 * @export
 * @interface V0037PartitionsResponse
 */
export interface V0037PartitionsResponse {
  /**
   * slurm errors
   * @type {Array<V0037Error>}
   * @memberof V0037PartitionsResponse
   */
  errors?: Array<V0037Error>;
  /**
   * partition info
   * @type {Array<V0037Partition>}
   * @memberof V0037PartitionsResponse
   */
  partitions?: Array<V0037Partition>;
}
/**
 *
 * @export
 * @interface V0037Ping
 */
export interface V0037Ping {
  /**
   * slurm controller hostname
   * @type {string}
   * @memberof V0037Ping
   */
  hostname?: string;
  /**
   * slurm controller host up
   * @type {string}
   * @memberof V0037Ping
   */
  ping?: V0037PingPingEnum;
  /**
   * slurm controller mode
   * @type {string}
   * @memberof V0037Ping
   */
  mode?: string;
  /**
   * slurm controller status
   * @type {number}
   * @memberof V0037Ping
   */
  status?: number;
}

/**
 * @export
 * @enum {string}
 */
export enum V0037PingPingEnum {
  Up = 'UP',
  Down = 'DOWN',
}

/**
 *
 * @export
 * @interface V0037Pings
 */
export interface V0037Pings {
  /**
   * slurm errors
   * @type {Array<V0037Error>}
   * @memberof V0037Pings
   */
  errors?: Array<V0037Error>;
  /**
   * slurm controller pings
   * @type {Array<V0037Ping>}
   * @memberof V0037Pings
   */
  pings?: Array<V0037Ping>;
}
/**
 *
 * @export
 * @interface V0037Reservation
 */
export interface V0037Reservation {
  /**
   * Allowed accounts
   * @type {string}
   * @memberof V0037Reservation
   */
  accounts?: string;
  /**
   * Reserved burst buffer
   * @type {string}
   * @memberof V0037Reservation
   */
  burst_buffer?: string;
  /**
   * Number of reserved cores
   * @type {number}
   * @memberof V0037Reservation
   */
  core_count?: number;
  /**
   * Number of reserved specialized cores
   * @type {number}
   * @memberof V0037Reservation
   */
  core_spec_cnt?: number;
  /**
   * End time of the reservation
   * @type {number}
   * @memberof V0037Reservation
   */
  end_time?: number;
  /**
   * List of features
   * @type {string}
   * @memberof V0037Reservation
   */
  features?: string;
  /**
   * Reservation options
   * @type {Array<string>}
   * @memberof V0037Reservation
   */
  flags?: Array<string>;
  /**
   * List of groups permitted to use the reserved nodes
   * @type {string}
   * @memberof V0037Reservation
   */
  groups?: string;
  /**
   * List of licenses
   * @type {string}
   * @memberof V0037Reservation
   */
  licenses?: string;
  /**
   * Maximum delay in which jobs outside of the reservation will be permitted to overlap once any jobs are queued for the reservation
   * @type {number}
   * @memberof V0037Reservation
   */
  max_start_delay?: number;
  /**
   * Reservationn name
   * @type {string}
   * @memberof V0037Reservation
   */
  name?: string;
  /**
   * Count of nodes reserved
   * @type {number}
   * @memberof V0037Reservation
   */
  node_count?: number;
  /**
   * List of reserved nodes
   * @type {string}
   * @memberof V0037Reservation
   */
  node_list?: string;
  /**
   * Partition
   * @type {string}
   * @memberof V0037Reservation
   */
  partition?: string;
  /**
   *
   * @type {V0037ReservationPurgeCompleted}
   * @memberof V0037Reservation
   */
  purge_completed?: V0037ReservationPurgeCompleted;
  /**
   * Start time of reservation
   * @type {number}
   * @memberof V0037Reservation
   */
  start_time?: number;
  /**
   * amount of power to reserve in watts
   * @type {number}
   * @memberof V0037Reservation
   */
  watts?: number;
  /**
   * List of TRES
   * @type {string}
   * @memberof V0037Reservation
   */
  tres?: string;
  /**
   * List of users
   * @type {string}
   * @memberof V0037Reservation
   */
  users?: string;
}
/**
 * If PURGE_COMP flag is set the amount of seconds this reservation will sit idle until it is revoked
 * @export
 * @interface V0037ReservationPurgeCompleted
 */
export interface V0037ReservationPurgeCompleted {
  /**
   * amount of seconds this reservation will sit idle until it is revoked
   * @type {number}
   * @memberof V0037ReservationPurgeCompleted
   */
  time?: number;
}
/**
 *
 * @export
 * @interface V0037ReservationsResponse
 */
export interface V0037ReservationsResponse {
  /**
   * slurm errors
   * @type {Array<V0037Error>}
   * @memberof V0037ReservationsResponse
   */
  errors?: Array<V0037Error>;
  /**
   * reservation info
   * @type {Array<V0037Reservation>}
   * @memberof V0037ReservationsResponse
   */
  reservations?: Array<V0037Reservation>;
}
/**
 * POSIX signal name
 * @export
 * @enum {string}
 */

export enum V0037Signal {
  Hup = 'HUP',
  Int = 'INT',
  Quit = 'QUIT',
  Abrt = 'ABRT',
  Kill = 'KILL',
  Alrm = 'ALRM',
  Term = 'TERM',
  Usr1 = 'USR1',
  Usr2 = 'USR2',
  Urg = 'URG',
  Cont = 'CONT',
  Stop = 'STOP',
  Tstp = 'TSTP',
  Ttin = 'TTIN',
  Ttou = 'TTOU',
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary get diagnostics
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035DiagGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurm/v0.0.35/diag`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary cancel or signal job
     * @param {number} jobId Slurm Job ID
     * @param {Signal} [signal] signal to send to job
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035JobJobIdDelete: async (
      jobId: number,
      signal?: Signal,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists('slurmV0035JobJobIdDelete', 'jobId', jobId);
      const localVarPath = `/slurm/v0.0.35/job/{job_id}`.replace(
        `{${'job_id'}}`,
        encodeURIComponent(String(jobId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      if (signal !== undefined) {
        localVarQueryParameter['signal'] = signal;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get job info
     * @param {number} jobId Slurm Job ID
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035JobJobIdGet: async (
      jobId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists('slurmV0035JobJobIdGet', 'jobId', jobId);
      const localVarPath = `/slurm/v0.0.35/job/{job_id}`.replace(
        `{${'job_id'}}`,
        encodeURIComponent(String(jobId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary update job
     * @param {number} jobId Slurm Job ID
     * @param {JobProperties} jobProperties update job
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035JobJobIdPost: async (
      jobId: number,
      jobProperties: JobProperties,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists('slurmV0035JobJobIdPost', 'jobId', jobId);
      // verify required parameter 'jobProperties' is not null or undefined
      assertParamExists('slurmV0035JobJobIdPost', 'jobProperties', jobProperties);
      const localVarPath = `/slurm/v0.0.35/job/{job_id}`.replace(
        `{${'job_id'}}`,
        encodeURIComponent(String(jobId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        jobProperties,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary submit new job
     * @param {JobProperties} jobProperties submit new job
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035JobSubmitPost: async (
      jobProperties: JobProperties,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobProperties' is not null or undefined
      assertParamExists('slurmV0035JobSubmitPost', 'jobProperties', jobProperties);
      const localVarPath = `/slurm/v0.0.35/job/submit`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        jobProperties,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get list of jobs
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035JobsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurm/v0.0.35/jobs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get node info
     * @param {string} nodeName Slurm Node Name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035NodeNodeNameGet: async (
      nodeName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'nodeName' is not null or undefined
      assertParamExists('slurmV0035NodeNodeNameGet', 'nodeName', nodeName);
      const localVarPath = `/slurm/v0.0.35/node/{node_name}`.replace(
        `{${'node_name'}}`,
        encodeURIComponent(String(nodeName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get all node info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035NodesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurm/v0.0.35/nodes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get partition info
     * @param {string} partitionName Slurm Partition Name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035PartitionPartitionNameGet: async (
      partitionName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'partitionName' is not null or undefined
      assertParamExists('slurmV0035PartitionPartitionNameGet', 'partitionName', partitionName);
      const localVarPath = `/slurm/v0.0.35/partition/{partition_name}`.replace(
        `{${'partition_name'}}`,
        encodeURIComponent(String(partitionName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get all partition info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035PartitionsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurm/v0.0.35/partitions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary ping test
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035PingGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurm/v0.0.35/ping`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary get diagnostics
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async slurmV0035DiagGet(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0035DiagGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary cancel or signal job
     * @param {number} jobId Slurm Job ID
     * @param {Signal} [signal] signal to send to job
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async slurmV0035JobJobIdDelete(
      jobId: number,
      signal?: Signal,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0035JobJobIdDelete(
        jobId,
        signal,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get job info
     * @param {number} jobId Slurm Job ID
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async slurmV0035JobJobIdGet(
      jobId: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0035JobJobIdGet(
        jobId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary update job
     * @param {number} jobId Slurm Job ID
     * @param {JobProperties} jobProperties update job
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async slurmV0035JobJobIdPost(
      jobId: number,
      jobProperties: JobProperties,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0035JobJobIdPost(
        jobId,
        jobProperties,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary submit new job
     * @param {JobProperties} jobProperties submit new job
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async slurmV0035JobSubmitPost(
      jobProperties: JobProperties,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0035JobSubmitPost(
        jobProperties,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get list of jobs
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async slurmV0035JobsGet(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0035JobsGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get node info
     * @param {string} nodeName Slurm Node Name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async slurmV0035NodeNodeNameGet(
      nodeName: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0035NodeNodeNameGet(
        nodeName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get all node info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async slurmV0035NodesGet(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0035NodesGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get partition info
     * @param {string} partitionName Slurm Partition Name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async slurmV0035PartitionPartitionNameGet(
      partitionName: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0035PartitionPartitionNameGet(
        partitionName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get all partition info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async slurmV0035PartitionsGet(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0035PartitionsGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary ping test
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async slurmV0035PingGet(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0035PingGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     *
     * @summary get diagnostics
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035DiagGet(options?: any): AxiosPromise<void> {
      return localVarFp.slurmV0035DiagGet(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary cancel or signal job
     * @param {number} jobId Slurm Job ID
     * @param {Signal} [signal] signal to send to job
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035JobJobIdDelete(jobId: number, signal?: Signal, options?: any): AxiosPromise<void> {
      return localVarFp
        .slurmV0035JobJobIdDelete(jobId, signal, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get job info
     * @param {number} jobId Slurm Job ID
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035JobJobIdGet(jobId: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .slurmV0035JobJobIdGet(jobId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary update job
     * @param {number} jobId Slurm Job ID
     * @param {JobProperties} jobProperties update job
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035JobJobIdPost(
      jobId: number,
      jobProperties: JobProperties,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .slurmV0035JobJobIdPost(jobId, jobProperties, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary submit new job
     * @param {JobProperties} jobProperties submit new job
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035JobSubmitPost(jobProperties: JobProperties, options?: any): AxiosPromise<void> {
      return localVarFp
        .slurmV0035JobSubmitPost(jobProperties, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get list of jobs
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035JobsGet(options?: any): AxiosPromise<void> {
      return localVarFp.slurmV0035JobsGet(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get node info
     * @param {string} nodeName Slurm Node Name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035NodeNodeNameGet(nodeName: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .slurmV0035NodeNodeNameGet(nodeName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get all node info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035NodesGet(options?: any): AxiosPromise<void> {
      return localVarFp.slurmV0035NodesGet(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get partition info
     * @param {string} partitionName Slurm Partition Name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035PartitionPartitionNameGet(partitionName: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .slurmV0035PartitionPartitionNameGet(partitionName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get all partition info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035PartitionsGet(options?: any): AxiosPromise<void> {
      return localVarFp.slurmV0035PartitionsGet(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary ping test
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    slurmV0035PingGet(options?: any): AxiosPromise<void> {
      return localVarFp.slurmV0035PingGet(options).then(request => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @summary get diagnostics
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public slurmV0035DiagGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .slurmV0035DiagGet(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary cancel or signal job
   * @param {number} jobId Slurm Job ID
   * @param {Signal} [signal] signal to send to job
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public slurmV0035JobJobIdDelete(jobId: number, signal?: Signal, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .slurmV0035JobJobIdDelete(jobId, signal, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get job info
   * @param {number} jobId Slurm Job ID
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public slurmV0035JobJobIdGet(jobId: number, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .slurmV0035JobJobIdGet(jobId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary update job
   * @param {number} jobId Slurm Job ID
   * @param {JobProperties} jobProperties update job
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public slurmV0035JobJobIdPost(
    jobId: number,
    jobProperties: JobProperties,
    options?: AxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .slurmV0035JobJobIdPost(jobId, jobProperties, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary submit new job
   * @param {JobProperties} jobProperties submit new job
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public slurmV0035JobSubmitPost(jobProperties: JobProperties, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .slurmV0035JobSubmitPost(jobProperties, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get list of jobs
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public slurmV0035JobsGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .slurmV0035JobsGet(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get node info
   * @param {string} nodeName Slurm Node Name
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public slurmV0035NodeNodeNameGet(nodeName: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .slurmV0035NodeNodeNameGet(nodeName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get all node info
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public slurmV0035NodesGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .slurmV0035NodesGet(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get partition info
   * @param {string} partitionName Slurm Partition Name
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public slurmV0035PartitionPartitionNameGet(partitionName: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .slurmV0035PartitionPartitionNameGet(partitionName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get all partition info
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public slurmV0035PartitionsGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .slurmV0035PartitionsGet(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary ping test
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public slurmV0035PingGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .slurmV0035PingGet(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * OpenapiApi - axios parameter creator
 * @export
 */
export const OpenapiApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Retrieve OpenAPI Specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    openapiGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/openapi`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve OpenAPI Specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    openapiJsonGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/openapi.json`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve OpenAPI Specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    openapiV3Get: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/openapi/v3`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve OpenAPI Specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    openapiYamlGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/openapi.yaml`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OpenapiApi - functional programming interface
 * @export
 */
export const OpenapiApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OpenapiApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Retrieve OpenAPI Specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async openapiGet(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.openapiGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve OpenAPI Specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async openapiJsonGet(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.openapiJsonGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve OpenAPI Specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async openapiV3Get(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.openapiV3Get(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve OpenAPI Specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async openapiYamlGet(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.openapiYamlGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * OpenapiApi - factory interface
 * @export
 */
export const OpenapiApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = OpenapiApiFp(configuration);
  return {
    /**
     *
     * @summary Retrieve OpenAPI Specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    openapiGet(options?: any): AxiosPromise<void> {
      return localVarFp.openapiGet(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve OpenAPI Specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    openapiJsonGet(options?: any): AxiosPromise<void> {
      return localVarFp.openapiJsonGet(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve OpenAPI Specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    openapiV3Get(options?: any): AxiosPromise<void> {
      return localVarFp.openapiV3Get(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve OpenAPI Specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    openapiYamlGet(options?: any): AxiosPromise<void> {
      return localVarFp.openapiYamlGet(options).then(request => request(axios, basePath));
    },
  };
};

/**
 * OpenapiApi - object-oriented interface
 * @export
 * @class OpenapiApi
 * @extends {BaseAPI}
 */
export class OpenapiApi extends BaseAPI {
  /**
   *
   * @summary Retrieve OpenAPI Specification
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OpenapiApi
   */
  public openapiGet(options?: AxiosRequestConfig) {
    return OpenapiApiFp(this.configuration)
      .openapiGet(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve OpenAPI Specification
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OpenapiApi
   */
  public openapiJsonGet(options?: AxiosRequestConfig) {
    return OpenapiApiFp(this.configuration)
      .openapiJsonGet(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve OpenAPI Specification
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OpenapiApi
   */
  public openapiV3Get(options?: AxiosRequestConfig) {
    return OpenapiApiFp(this.configuration)
      .openapiV3Get(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve OpenAPI Specification
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OpenapiApi
   */
  public openapiYamlGet(options?: AxiosRequestConfig) {
    return OpenapiApiFp(this.configuration)
      .openapiYamlGet(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SlurmApi - axios parameter creator
 * @export
 */
export const SlurmApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary cancel or signal job
     * @param {number} jobId Slurm Job ID
     * @param {V0037Signal} [signal] signal to send to job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldCancelJob: async (
      jobId: number,
      signal?: V0037Signal,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists('slurmctldCancelJob', 'jobId', jobId);
      const localVarPath = `/slurm/v0.0.37/job/{job_id}`.replace(
        `{${'job_id'}}`,
        encodeURIComponent(String(jobId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      if (signal !== undefined) {
        localVarQueryParameter['signal'] = signal;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary cancel or signal job
     * @param {number} jobId Slurm Job ID
     * @param {V0036Signal} [signal] signal to send to job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldCancelJob_1: async (
      jobId: number,
      signal?: V0036Signal,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists('slurmctldCancelJob_1', 'jobId', jobId);
      const localVarPath = `/slurm/v0.0.36/job/{job_id}`.replace(
        `{${'job_id'}}`,
        encodeURIComponent(String(jobId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      if (signal !== undefined) {
        localVarQueryParameter['signal'] = signal;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get diagnostics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldDiag: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurm/v0.0.37/diag`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get diagnostics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldDiag_2: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurm/v0.0.36/diag`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get job info
     * @param {number} jobId Slurm Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetJob: async (
      jobId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists('slurmctldGetJob', 'jobId', jobId);
      const localVarPath = `/slurm/v0.0.37/job/{job_id}`.replace(
        `{${'job_id'}}`,
        encodeURIComponent(String(jobId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get job info
     * @param {number} jobId Slurm Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetJob_3: async (
      jobId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists('slurmctldGetJob_3', 'jobId', jobId);
      const localVarPath = `/slurm/v0.0.36/job/{job_id}`.replace(
        `{${'job_id'}}`,
        encodeURIComponent(String(jobId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get list of jobs
     * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetJobs: async (
      updateTime?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/slurm/v0.0.37/jobs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      if (updateTime !== undefined) {
        localVarQueryParameter['update_time'] = updateTime;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get list of jobs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetJobs_4: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurm/v0.0.36/jobs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get node info
     * @param {string} nodeName Slurm Node Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetNode: async (
      nodeName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'nodeName' is not null or undefined
      assertParamExists('slurmctldGetNode', 'nodeName', nodeName);
      const localVarPath = `/slurm/v0.0.37/node/{node_name}`.replace(
        `{${'node_name'}}`,
        encodeURIComponent(String(nodeName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get node info
     * @param {string} nodeName Slurm Node Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetNode_5: async (
      nodeName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'nodeName' is not null or undefined
      assertParamExists('slurmctldGetNode_5', 'nodeName', nodeName);
      const localVarPath = `/slurm/v0.0.36/node/{node_name}`.replace(
        `{${'node_name'}}`,
        encodeURIComponent(String(nodeName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get all node info
     * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetNodes: async (
      updateTime?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/slurm/v0.0.37/nodes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      if (updateTime !== undefined) {
        localVarQueryParameter['update_time'] = updateTime;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get all node info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetNodes_6: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurm/v0.0.36/nodes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get partition info
     * @param {string} partitionName Slurm Partition Name
     * @param {number} [updateTime] Filter if there were no partition changes (not limited to partition in URL endpoint) since update_time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetPartition: async (
      partitionName: string,
      updateTime?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'partitionName' is not null or undefined
      assertParamExists('slurmctldGetPartition', 'partitionName', partitionName);
      const localVarPath = `/slurm/v0.0.37/partition/{partition_name}`.replace(
        `{${'partition_name'}}`,
        encodeURIComponent(String(partitionName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      if (updateTime !== undefined) {
        localVarQueryParameter['update_time'] = updateTime;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get partition info
     * @param {string} partitionName Slurm Partition Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetPartition_7: async (
      partitionName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'partitionName' is not null or undefined
      assertParamExists('slurmctldGetPartition_7', 'partitionName', partitionName);
      const localVarPath = `/slurm/v0.0.36/partition/{partition_name}`.replace(
        `{${'partition_name'}}`,
        encodeURIComponent(String(partitionName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get all partition info
     * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetPartitions: async (
      updateTime?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/slurm/v0.0.37/partitions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      if (updateTime !== undefined) {
        localVarQueryParameter['update_time'] = updateTime;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get all partition info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetPartitions_8: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurm/v0.0.36/partitions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get reservation info
     * @param {string} reservationName Slurm Reservation Name
     * @param {number} [updateTime] Filter if no reservation (not limited to reservation in URL) changed since update_time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetReservation: async (
      reservationName: string,
      updateTime?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'reservationName' is not null or undefined
      assertParamExists('slurmctldGetReservation', 'reservationName', reservationName);
      const localVarPath = `/slurm/v0.0.37/reservation/{reservation_name}`.replace(
        `{${'reservation_name'}}`,
        encodeURIComponent(String(reservationName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      if (updateTime !== undefined) {
        localVarQueryParameter['update_time'] = updateTime;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get all reservation info
     * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetReservations: async (
      updateTime?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/slurm/v0.0.37/reservations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      if (updateTime !== undefined) {
        localVarQueryParameter['update_time'] = updateTime;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary ping test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldPing: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurm/v0.0.37/ping`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary ping test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldPing_9: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurm/v0.0.36/ping`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary submit new job
     * @param {V0037JobSubmission} v0037JobSubmission submit new job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldSubmitJob: async (
      v0037JobSubmission: V0037JobSubmission,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'v0037JobSubmission' is not null or undefined
      assertParamExists('slurmctldSubmitJob', 'v0037JobSubmission', v0037JobSubmission);
      const localVarPath = `/slurm/v0.0.37/job/submit`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        v0037JobSubmission,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary submit new job
     * @param {V0036JobSubmission} v0036JobSubmission submit new job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldSubmitJob_10: async (
      v0036JobSubmission: V0036JobSubmission,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'v0036JobSubmission' is not null or undefined
      assertParamExists('slurmctldSubmitJob_10', 'v0036JobSubmission', v0036JobSubmission);
      const localVarPath = `/slurm/v0.0.36/job/submit`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        v0036JobSubmission,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary update job
     * @param {number} jobId Slurm Job ID
     * @param {V0037JobProperties} v0037JobProperties update job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldUpdateJob: async (
      jobId: number,
      v0037JobProperties: V0037JobProperties,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists('slurmctldUpdateJob', 'jobId', jobId);
      // verify required parameter 'v0037JobProperties' is not null or undefined
      assertParamExists('slurmctldUpdateJob', 'v0037JobProperties', v0037JobProperties);
      const localVarPath = `/slurm/v0.0.37/job/{job_id}`.replace(
        `{${'job_id'}}`,
        encodeURIComponent(String(jobId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        v0037JobProperties,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary update job
     * @param {number} jobId Slurm Job ID
     * @param {V0036JobProperties} v0036JobProperties update job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldUpdateJob_11: async (
      jobId: number,
      v0036JobProperties: V0036JobProperties,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists('slurmctldUpdateJob_11', 'jobId', jobId);
      // verify required parameter 'v0036JobProperties' is not null or undefined
      assertParamExists('slurmctldUpdateJob_11', 'v0036JobProperties', v0036JobProperties);
      const localVarPath = `/slurm/v0.0.36/job/{job_id}`.replace(
        `{${'job_id'}}`,
        encodeURIComponent(String(jobId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        v0036JobProperties,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add clusters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdAddClusters: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.36/clusters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add clusters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdAddClusters_12: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.37/clusters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add wckeys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdAddWckeys: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.36/wckeys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add wckeys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdAddWckeys_13: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.37/wckeys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete account
     * @param {string} accountName Slurm Account Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteAccount: async (
      accountName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountName' is not null or undefined
      assertParamExists('slurmdbdDeleteAccount', 'accountName', accountName);
      const localVarPath = `/slurmdb/v0.0.36/account/{account_name}`.replace(
        `{${'account_name'}}`,
        encodeURIComponent(String(accountName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete account
     * @param {string} accountName Slurm Account Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteAccount_14: async (
      accountName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountName' is not null or undefined
      assertParamExists('slurmdbdDeleteAccount_14', 'accountName', accountName);
      const localVarPath = `/slurmdb/v0.0.37/account/{account_name}`.replace(
        `{${'account_name'}}`,
        encodeURIComponent(String(accountName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete association
     * @param {string} account Account name
     * @param {string} user User name
     * @param {string} [cluster] Cluster name
     * @param {string} [partition] Partition Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteAssociation: async (
      account: string,
      user: string,
      cluster?: string,
      partition?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'account' is not null or undefined
      assertParamExists('slurmdbdDeleteAssociation', 'account', account);
      // verify required parameter 'user' is not null or undefined
      assertParamExists('slurmdbdDeleteAssociation', 'user', user);
      const localVarPath = `/slurmdb/v0.0.36/association`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      if (cluster !== undefined) {
        localVarQueryParameter['cluster'] = cluster;
      }

      if (account !== undefined) {
        localVarQueryParameter['account'] = account;
      }

      if (user !== undefined) {
        localVarQueryParameter['user'] = user;
      }

      if (partition !== undefined) {
        localVarQueryParameter['partition'] = partition;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete association
     * @param {string} account Account name
     * @param {string} user User name
     * @param {string} [cluster] Cluster name
     * @param {string} [partition] Partition Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteAssociation_15: async (
      account: string,
      user: string,
      cluster?: string,
      partition?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'account' is not null or undefined
      assertParamExists('slurmdbdDeleteAssociation_15', 'account', account);
      // verify required parameter 'user' is not null or undefined
      assertParamExists('slurmdbdDeleteAssociation_15', 'user', user);
      const localVarPath = `/slurmdb/v0.0.37/association`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      if (cluster !== undefined) {
        localVarQueryParameter['cluster'] = cluster;
      }

      if (account !== undefined) {
        localVarQueryParameter['account'] = account;
      }

      if (user !== undefined) {
        localVarQueryParameter['user'] = user;
      }

      if (partition !== undefined) {
        localVarQueryParameter['partition'] = partition;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete cluster
     * @param {string} clusterName Slurm cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteCluster: async (
      clusterName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterName' is not null or undefined
      assertParamExists('slurmdbdDeleteCluster', 'clusterName', clusterName);
      const localVarPath = `/slurmdb/v0.0.36/cluster/{cluster_name}`.replace(
        `{${'cluster_name'}}`,
        encodeURIComponent(String(clusterName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete cluster
     * @param {string} clusterName Slurm cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteCluster_16: async (
      clusterName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterName' is not null or undefined
      assertParamExists('slurmdbdDeleteCluster_16', 'clusterName', clusterName);
      const localVarPath = `/slurmdb/v0.0.37/cluster/{cluster_name}`.replace(
        `{${'cluster_name'}}`,
        encodeURIComponent(String(clusterName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete QOS
     * @param {string} qosName Slurm QOS Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteQos: async (
      qosName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'qosName' is not null or undefined
      assertParamExists('slurmdbdDeleteQos', 'qosName', qosName);
      const localVarPath = `/slurmdb/v0.0.36/qos/{qos_name}`.replace(
        `{${'qos_name'}}`,
        encodeURIComponent(String(qosName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete QOS
     * @param {string} qosName Slurm QOS Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteQos_17: async (
      qosName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'qosName' is not null or undefined
      assertParamExists('slurmdbdDeleteQos_17', 'qosName', qosName);
      const localVarPath = `/slurmdb/v0.0.37/qos/{qos_name}`.replace(
        `{${'qos_name'}}`,
        encodeURIComponent(String(qosName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete user
     * @param {string} userName Slurm User Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteUser: async (
      userName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userName' is not null or undefined
      assertParamExists('slurmdbdDeleteUser', 'userName', userName);
      const localVarPath = `/slurmdb/v0.0.36/user/{user_name}`.replace(
        `{${'user_name'}}`,
        encodeURIComponent(String(userName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete user
     * @param {string} userName Slurm User Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteUser_18: async (
      userName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userName' is not null or undefined
      assertParamExists('slurmdbdDeleteUser_18', 'userName', userName);
      const localVarPath = `/slurmdb/v0.0.37/user/{user_name}`.replace(
        `{${'user_name'}}`,
        encodeURIComponent(String(userName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete wckey
     * @param {string} wckey Slurm wckey name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteWckey: async (
      wckey: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'wckey' is not null or undefined
      assertParamExists('slurmdbdDeleteWckey', 'wckey', wckey);
      const localVarPath = `/slurmdb/v0.0.36/wckey/{wckey}`.replace(
        `{${'wckey'}}`,
        encodeURIComponent(String(wckey))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete wckey
     * @param {string} wckey Slurm wckey name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteWckey_19: async (
      wckey: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'wckey' is not null or undefined
      assertParamExists('slurmdbdDeleteWckey_19', 'wckey', wckey);
      const localVarPath = `/slurmdb/v0.0.37/wckey/{wckey}`.replace(
        `{${'wckey'}}`,
        encodeURIComponent(String(wckey))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get slurmdb diagnostics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDiag: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.36/diag`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get slurmdb diagnostics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDiag_20: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.37/diag`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get account info
     * @param {string} accountName Slurm Account Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetAccount: async (
      accountName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountName' is not null or undefined
      assertParamExists('slurmdbdGetAccount', 'accountName', accountName);
      const localVarPath = `/slurmdb/v0.0.36/account/{account_name}`.replace(
        `{${'account_name'}}`,
        encodeURIComponent(String(accountName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get account info
     * @param {string} accountName Slurm Account Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetAccount_21: async (
      accountName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountName' is not null or undefined
      assertParamExists('slurmdbdGetAccount_21', 'accountName', accountName);
      const localVarPath = `/slurmdb/v0.0.37/account/{account_name}`.replace(
        `{${'account_name'}}`,
        encodeURIComponent(String(accountName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get account list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetAccounts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.36/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get account list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetAccounts_22: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.37/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get association info
     * @param {string} [cluster] Cluster name
     * @param {string} [account] Account name
     * @param {string} [user] User name
     * @param {string} [partition] Partition Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetAssociation: async (
      cluster?: string,
      account?: string,
      user?: string,
      partition?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.36/association`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      if (cluster !== undefined) {
        localVarQueryParameter['cluster'] = cluster;
      }

      if (account !== undefined) {
        localVarQueryParameter['account'] = account;
      }

      if (user !== undefined) {
        localVarQueryParameter['user'] = user;
      }

      if (partition !== undefined) {
        localVarQueryParameter['partition'] = partition;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get association info
     * @param {string} [cluster] Cluster name
     * @param {string} [account] Account name
     * @param {string} [user] User name
     * @param {string} [partition] Partition Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetAssociation_23: async (
      cluster?: string,
      account?: string,
      user?: string,
      partition?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.37/association`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      if (cluster !== undefined) {
        localVarQueryParameter['cluster'] = cluster;
      }

      if (account !== undefined) {
        localVarQueryParameter['account'] = account;
      }

      if (user !== undefined) {
        localVarQueryParameter['user'] = user;
      }

      if (partition !== undefined) {
        localVarQueryParameter['partition'] = partition;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get association list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetAssociations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.36/associations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get association list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetAssociations_24: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.37/associations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get cluster info
     * @param {string} clusterName Slurm cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetCluster: async (
      clusterName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterName' is not null or undefined
      assertParamExists('slurmdbdGetCluster', 'clusterName', clusterName);
      const localVarPath = `/slurmdb/v0.0.36/cluster/{cluster_name}`.replace(
        `{${'cluster_name'}}`,
        encodeURIComponent(String(clusterName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get cluster info
     * @param {string} clusterName Slurm cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetCluster_25: async (
      clusterName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterName' is not null or undefined
      assertParamExists('slurmdbdGetCluster_25', 'clusterName', clusterName);
      const localVarPath = `/slurmdb/v0.0.37/cluster/{cluster_name}`.replace(
        `{${'cluster_name'}}`,
        encodeURIComponent(String(clusterName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get cluster list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetClusters: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.36/clusters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get cluster list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetClusters_26: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.37/clusters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Dump all configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetDbConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.36/config`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Dump all configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetDbConfig_27: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.37/config`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
     * @summary Get job info
     * @param {number} jobId Slurm Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetJob: async (
      jobId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists('slurmdbdGetJob', 'jobId', jobId);
      const localVarPath = `/slurmdb/v0.0.36/job/{job_id}`.replace(
        `{${'job_id'}}`,
        encodeURIComponent(String(jobId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
     * @summary Get job info
     * @param {number} jobId Slurm Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetJob_28: async (
      jobId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'jobId' is not null or undefined
      assertParamExists('slurmdbdGetJob_28', 'jobId', jobId);
      const localVarPath = `/slurmdb/v0.0.37/job/{job_id}`.replace(
        `{${'job_id'}}`,
        encodeURIComponent(String(jobId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get job list
     * @param {string} [submitTime] Filter by submission time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [startTime] Filter by start time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [endTime] Filter by end time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [account] Comma delimited list of accounts to match
     * @param {string} [association] Comma delimited list of associations to match
     * @param {string} [cluster] Comma delimited list of cluster to match
     * @param {string} [constraints] Comma delimited list of constraints to match
     * @param {string} [cpusMax] Number of CPUs high range
     * @param {string} [cpusMin] Number of CPUs low range
     * @param {boolean} [skipSteps] Report job step information
     * @param {boolean} [disableWaitForResult] Disable waiting for result from slurmdbd
     * @param {string} [exitCode] Exit code of job
     * @param {string} [format] Comma delimited list of formats to match
     * @param {string} [group] Comma delimited list of groups to match
     * @param {string} [jobName] Comma delimited list of job names to match
     * @param {string} [nodesMax] Number of nodes high range
     * @param {string} [nodesMin] Number of nodes low range
     * @param {string} [partition] Comma delimited list of partitions to match
     * @param {string} [qos] Comma delimited list of QOS to match
     * @param {string} [reason] Comma delimited list of job reasons to match
     * @param {string} [reservation] Comma delimited list of reservations to match
     * @param {string} [state] Comma delimited list of states to match
     * @param {string} [step] Comma delimited list of job steps to match
     * @param {string} [node] Comma delimited list of used nodes to match
     * @param {string} [wckey] Comma delimited list of wckeys to match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetJobs: async (
      submitTime?: string,
      startTime?: string,
      endTime?: string,
      account?: string,
      association?: string,
      cluster?: string,
      constraints?: string,
      cpusMax?: string,
      cpusMin?: string,
      skipSteps?: boolean,
      disableWaitForResult?: boolean,
      exitCode?: string,
      format?: string,
      group?: string,
      jobName?: string,
      nodesMax?: string,
      nodesMin?: string,
      partition?: string,
      qos?: string,
      reason?: string,
      reservation?: string,
      state?: string,
      step?: string,
      node?: string,
      wckey?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.36/jobs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      if (submitTime !== undefined) {
        localVarQueryParameter['submit_time'] = submitTime;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['start_time'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['end_time'] = endTime;
      }

      if (account !== undefined) {
        localVarQueryParameter['account'] = account;
      }

      if (association !== undefined) {
        localVarQueryParameter['association'] = association;
      }

      if (cluster !== undefined) {
        localVarQueryParameter['cluster'] = cluster;
      }

      if (constraints !== undefined) {
        localVarQueryParameter['constraints'] = constraints;
      }

      if (cpusMax !== undefined) {
        localVarQueryParameter['cpus_max'] = cpusMax;
      }

      if (cpusMin !== undefined) {
        localVarQueryParameter['cpus_min'] = cpusMin;
      }

      if (skipSteps !== undefined) {
        localVarQueryParameter['skip_steps'] = skipSteps;
      }

      if (disableWaitForResult !== undefined) {
        localVarQueryParameter['disable_wait_for_result'] = disableWaitForResult;
      }

      if (exitCode !== undefined) {
        localVarQueryParameter['exit_code'] = exitCode;
      }

      if (format !== undefined) {
        localVarQueryParameter['format'] = format;
      }

      if (group !== undefined) {
        localVarQueryParameter['group'] = group;
      }

      if (jobName !== undefined) {
        localVarQueryParameter['job_name'] = jobName;
      }

      if (nodesMax !== undefined) {
        localVarQueryParameter['nodes_max'] = nodesMax;
      }

      if (nodesMin !== undefined) {
        localVarQueryParameter['nodes_min'] = nodesMin;
      }

      if (partition !== undefined) {
        localVarQueryParameter['partition'] = partition;
      }

      if (qos !== undefined) {
        localVarQueryParameter['qos'] = qos;
      }

      if (reason !== undefined) {
        localVarQueryParameter['reason'] = reason;
      }

      if (reservation !== undefined) {
        localVarQueryParameter['reservation'] = reservation;
      }

      if (state !== undefined) {
        localVarQueryParameter['state'] = state;
      }

      if (step !== undefined) {
        localVarQueryParameter['step'] = step;
      }

      if (node !== undefined) {
        localVarQueryParameter['node'] = node;
      }

      if (wckey !== undefined) {
        localVarQueryParameter['wckey'] = wckey;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get job list
     * @param {string} [submitTime] Filter by submission time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [startTime] Filter by start time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [endTime] Filter by end time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [account] Comma delimited list of accounts to match
     * @param {string} [association] Comma delimited list of associations to match
     * @param {string} [cluster] Comma delimited list of cluster to match
     * @param {string} [constraints] Comma delimited list of constraints to match
     * @param {string} [cpusMax] Number of CPUs high range
     * @param {string} [cpusMin] Number of CPUs low range
     * @param {boolean} [skipSteps] Report job step information
     * @param {boolean} [disableWaitForResult] Disable waiting for result from slurmdbd
     * @param {string} [exitCode] Exit code of job
     * @param {string} [format] Comma delimited list of formats to match
     * @param {string} [group] Comma delimited list of groups to match
     * @param {string} [jobName] Comma delimited list of job names to match
     * @param {string} [nodesMax] Number of nodes high range
     * @param {string} [nodesMin] Number of nodes low range
     * @param {string} [partition] Comma delimited list of partitions to match
     * @param {string} [qos] Comma delimited list of QOS to match
     * @param {string} [reason] Comma delimited list of job reasons to match
     * @param {string} [reservation] Comma delimited list of reservations to match
     * @param {string} [state] Comma delimited list of states to match
     * @param {string} [step] Comma delimited list of job steps to match
     * @param {string} [node] Comma delimited list of used nodes to match
     * @param {string} [wckey] Comma delimited list of wckeys to match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetJobs_29: async (
      submitTime?: string,
      startTime?: string,
      endTime?: string,
      account?: string,
      association?: string,
      cluster?: string,
      constraints?: string,
      cpusMax?: string,
      cpusMin?: string,
      skipSteps?: boolean,
      disableWaitForResult?: boolean,
      exitCode?: string,
      format?: string,
      group?: string,
      jobName?: string,
      nodesMax?: string,
      nodesMin?: string,
      partition?: string,
      qos?: string,
      reason?: string,
      reservation?: string,
      state?: string,
      step?: string,
      node?: string,
      wckey?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.37/jobs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      if (submitTime !== undefined) {
        localVarQueryParameter['submit_time'] = submitTime;
      }

      if (startTime !== undefined) {
        localVarQueryParameter['start_time'] = startTime;
      }

      if (endTime !== undefined) {
        localVarQueryParameter['end_time'] = endTime;
      }

      if (account !== undefined) {
        localVarQueryParameter['account'] = account;
      }

      if (association !== undefined) {
        localVarQueryParameter['association'] = association;
      }

      if (cluster !== undefined) {
        localVarQueryParameter['cluster'] = cluster;
      }

      if (constraints !== undefined) {
        localVarQueryParameter['constraints'] = constraints;
      }

      if (cpusMax !== undefined) {
        localVarQueryParameter['cpus_max'] = cpusMax;
      }

      if (cpusMin !== undefined) {
        localVarQueryParameter['cpus_min'] = cpusMin;
      }

      if (skipSteps !== undefined) {
        localVarQueryParameter['skip_steps'] = skipSteps;
      }

      if (disableWaitForResult !== undefined) {
        localVarQueryParameter['disable_wait_for_result'] = disableWaitForResult;
      }

      if (exitCode !== undefined) {
        localVarQueryParameter['exit_code'] = exitCode;
      }

      if (format !== undefined) {
        localVarQueryParameter['format'] = format;
      }

      if (group !== undefined) {
        localVarQueryParameter['group'] = group;
      }

      if (jobName !== undefined) {
        localVarQueryParameter['job_name'] = jobName;
      }

      if (nodesMax !== undefined) {
        localVarQueryParameter['nodes_max'] = nodesMax;
      }

      if (nodesMin !== undefined) {
        localVarQueryParameter['nodes_min'] = nodesMin;
      }

      if (partition !== undefined) {
        localVarQueryParameter['partition'] = partition;
      }

      if (qos !== undefined) {
        localVarQueryParameter['qos'] = qos;
      }

      if (reason !== undefined) {
        localVarQueryParameter['reason'] = reason;
      }

      if (reservation !== undefined) {
        localVarQueryParameter['reservation'] = reservation;
      }

      if (state !== undefined) {
        localVarQueryParameter['state'] = state;
      }

      if (step !== undefined) {
        localVarQueryParameter['step'] = step;
      }

      if (node !== undefined) {
        localVarQueryParameter['node'] = node;
      }

      if (wckey !== undefined) {
        localVarQueryParameter['wckey'] = wckey;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get QOS list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetQos: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.36/qos`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get QOS list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetQos_30: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.37/qos`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get QOS info
     * @param {string} qosName Slurm QOS Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetSingleQos: async (
      qosName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'qosName' is not null or undefined
      assertParamExists('slurmdbdGetSingleQos', 'qosName', qosName);
      const localVarPath = `/slurmdb/v0.0.36/qos/{qos_name}`.replace(
        `{${'qos_name'}}`,
        encodeURIComponent(String(qosName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get QOS info
     * @param {string} qosName Slurm QOS Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetSingleQos_31: async (
      qosName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'qosName' is not null or undefined
      assertParamExists('slurmdbdGetSingleQos_31', 'qosName', qosName);
      const localVarPath = `/slurmdb/v0.0.37/qos/{qos_name}`.replace(
        `{${'qos_name'}}`,
        encodeURIComponent(String(qosName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get TRES info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetTres: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.36/tres`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get TRES info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetTres_32: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.37/tres`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user info
     * @param {string} userName Slurm User Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetUser: async (
      userName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userName' is not null or undefined
      assertParamExists('slurmdbdGetUser', 'userName', userName);
      const localVarPath = `/slurmdb/v0.0.36/user/{user_name}`.replace(
        `{${'user_name'}}`,
        encodeURIComponent(String(userName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user info
     * @param {string} userName Slurm User Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetUser_33: async (
      userName: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userName' is not null or undefined
      assertParamExists('slurmdbdGetUser_33', 'userName', userName);
      const localVarPath = `/slurmdb/v0.0.37/user/{user_name}`.replace(
        `{${'user_name'}}`,
        encodeURIComponent(String(userName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.36/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetUsers_34: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.37/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get wckey info
     * @param {string} wckey Slurm wckey name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetWckey: async (
      wckey: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'wckey' is not null or undefined
      assertParamExists('slurmdbdGetWckey', 'wckey', wckey);
      const localVarPath = `/slurmdb/v0.0.36/wckey/{wckey}`.replace(
        `{${'wckey'}}`,
        encodeURIComponent(String(wckey))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get wckey info
     * @param {string} wckey Slurm wckey name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetWckey_35: async (
      wckey: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'wckey' is not null or undefined
      assertParamExists('slurmdbdGetWckey_35', 'wckey', wckey);
      const localVarPath = `/slurmdb/v0.0.37/wckey/{wckey}`.replace(
        `{${'wckey'}}`,
        encodeURIComponent(String(wckey))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get wckey list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetWckeys: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.36/wckeys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get wckey list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetWckeys_36: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.37/wckeys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Load all configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdSetDbConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.36/config`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Load all configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdSetDbConfig_37: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.37/config`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdUpdateAccount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.36/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdUpdateAccount_38: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.37/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set TRES info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdUpdateTres: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.36/tres`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set TRES info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdUpdateTres_39: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.37/tres`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdUpdateUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.36/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdUpdateUsers_40: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/slurmdb/v0.0.37/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication token required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-TOKEN', configuration);

      // authentication user required
      await setApiKeyToObject(localVarHeaderParameter, 'X-SLURM-USER-NAME', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SlurmApi - functional programming interface
 * @export
 */
export const SlurmApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SlurmApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary cancel or signal job
     * @param {number} jobId Slurm Job ID
     * @param {V0037Signal} [signal] signal to send to job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldCancelJob(
      jobId: number,
      signal?: V0037Signal,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldCancelJob(
        jobId,
        signal,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary cancel or signal job
     * @param {number} jobId Slurm Job ID
     * @param {V0036Signal} [signal] signal to send to job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldCancelJob_1(
      jobId: number,
      signal?: V0036Signal,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldCancelJob_1(
        jobId,
        signal,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get diagnostics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldDiag(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0037Diag>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldDiag(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get diagnostics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldDiag_2(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0036Diag>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldDiag_2(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get job info
     * @param {number} jobId Slurm Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldGetJob(
      jobId: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0037JobsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldGetJob(jobId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get job info
     * @param {number} jobId Slurm Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldGetJob_3(
      jobId: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0036JobsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldGetJob_3(jobId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get list of jobs
     * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldGetJobs(
      updateTime?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0037JobsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldGetJobs(
        updateTime,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get list of jobs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldGetJobs_4(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0036JobsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldGetJobs_4(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get node info
     * @param {string} nodeName Slurm Node Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldGetNode(
      nodeName: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0037NodesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldGetNode(nodeName, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get node info
     * @param {string} nodeName Slurm Node Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldGetNode_5(
      nodeName: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0036NodesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldGetNode_5(
        nodeName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get all node info
     * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldGetNodes(
      updateTime?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0037NodesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldGetNodes(
        updateTime,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get all node info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldGetNodes_6(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0036NodesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldGetNodes_6(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get partition info
     * @param {string} partitionName Slurm Partition Name
     * @param {number} [updateTime] Filter if there were no partition changes (not limited to partition in URL endpoint) since update_time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldGetPartition(
      partitionName: string,
      updateTime?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0037PartitionsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldGetPartition(
        partitionName,
        updateTime,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get partition info
     * @param {string} partitionName Slurm Partition Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldGetPartition_7(
      partitionName: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0036PartitionsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldGetPartition_7(
        partitionName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get all partition info
     * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldGetPartitions(
      updateTime?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0037PartitionsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldGetPartitions(
        updateTime,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get all partition info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldGetPartitions_8(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0036PartitionsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldGetPartitions_8(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get reservation info
     * @param {string} reservationName Slurm Reservation Name
     * @param {number} [updateTime] Filter if no reservation (not limited to reservation in URL) changed since update_time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldGetReservation(
      reservationName: string,
      updateTime?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0037ReservationsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldGetReservation(
        reservationName,
        updateTime,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get all reservation info
     * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldGetReservations(
      updateTime?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0037ReservationsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldGetReservations(
        updateTime,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary ping test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldPing(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0037Pings>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldPing(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary ping test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldPing_9(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0036Pings>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldPing_9(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary submit new job
     * @param {V0037JobSubmission} v0037JobSubmission submit new job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldSubmitJob(
      v0037JobSubmission: V0037JobSubmission,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0037JobSubmissionResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldSubmitJob(
        v0037JobSubmission,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary submit new job
     * @param {V0036JobSubmission} v0036JobSubmission submit new job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldSubmitJob_10(
      v0036JobSubmission: V0036JobSubmission,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0036JobSubmissionResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldSubmitJob_10(
        v0036JobSubmission,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary update job
     * @param {number} jobId Slurm Job ID
     * @param {V0037JobProperties} v0037JobProperties update job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldUpdateJob(
      jobId: number,
      v0037JobProperties: V0037JobProperties,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldUpdateJob(
        jobId,
        v0037JobProperties,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary update job
     * @param {number} jobId Slurm Job ID
     * @param {V0036JobProperties} v0036JobProperties update job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmctldUpdateJob_11(
      jobId: number,
      v0036JobProperties: V0036JobProperties,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmctldUpdateJob_11(
        jobId,
        v0036JobProperties,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Add clusters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdAddClusters(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036ResponseClusterAdd>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdAddClusters(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Add clusters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdAddClusters_12(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037ResponseClusterAdd>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdAddClusters_12(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Add wckeys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdAddWckeys(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036ResponseWckeyAdd>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdAddWckeys(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Add wckeys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdAddWckeys_13(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037ResponseWckeyAdd>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdAddWckeys_13(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete account
     * @param {string} accountName Slurm Account Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdDeleteAccount(
      accountName: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036ResponseAccountDelete>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdDeleteAccount(
        accountName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete account
     * @param {string} accountName Slurm Account Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdDeleteAccount_14(
      accountName: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037ResponseAccountDelete>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdDeleteAccount_14(
        accountName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete association
     * @param {string} account Account name
     * @param {string} user User name
     * @param {string} [cluster] Cluster name
     * @param {string} [partition] Partition Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdDeleteAssociation(
      account: string,
      user: string,
      cluster?: string,
      partition?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036ResponseAssociationDelete>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdDeleteAssociation(
        account,
        user,
        cluster,
        partition,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete association
     * @param {string} account Account name
     * @param {string} user User name
     * @param {string} [cluster] Cluster name
     * @param {string} [partition] Partition Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdDeleteAssociation_15(
      account: string,
      user: string,
      cluster?: string,
      partition?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037ResponseAssociationDelete>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdDeleteAssociation_15(
        account,
        user,
        cluster,
        partition,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete cluster
     * @param {string} clusterName Slurm cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdDeleteCluster(
      clusterName: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036ResponseClusterDelete>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdDeleteCluster(
        clusterName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete cluster
     * @param {string} clusterName Slurm cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdDeleteCluster_16(
      clusterName: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037ResponseClusterDelete>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdDeleteCluster_16(
        clusterName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete QOS
     * @param {string} qosName Slurm QOS Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdDeleteQos(
      qosName: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036ResponseQosDelete>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdDeleteQos(qosName, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete QOS
     * @param {string} qosName Slurm QOS Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdDeleteQos_17(
      qosName: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037ResponseQosDelete>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdDeleteQos_17(
        qosName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete user
     * @param {string} userName Slurm User Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdDeleteUser(
      userName: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036ResponseUserDelete>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdDeleteUser(
        userName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete user
     * @param {string} userName Slurm User Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdDeleteUser_18(
      userName: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037ResponseUserDelete>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdDeleteUser_18(
        userName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete wckey
     * @param {string} wckey Slurm wckey name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdDeleteWckey(
      wckey: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036ResponseWckeyDelete>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdDeleteWckey(wckey, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete wckey
     * @param {string} wckey Slurm wckey name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdDeleteWckey_19(
      wckey: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037ResponseWckeyDelete>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdDeleteWckey_19(
        wckey,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get slurmdb diagnostics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdDiag(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036Diag>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdDiag(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get slurmdb diagnostics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdDiag_20(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037Diag>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdDiag_20(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get account info
     * @param {string} accountName Slurm Account Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetAccount(
      accountName: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036AccountInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetAccount(
        accountName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get account info
     * @param {string} accountName Slurm Account Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetAccount_21(
      accountName: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037AccountInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetAccount_21(
        accountName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get account list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetAccounts(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036AccountInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetAccounts(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get account list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetAccounts_22(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037AccountInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetAccounts_22(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get association info
     * @param {string} [cluster] Cluster name
     * @param {string} [account] Account name
     * @param {string} [user] User name
     * @param {string} [partition] Partition Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetAssociation(
      cluster?: string,
      account?: string,
      user?: string,
      partition?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036AssociationsInfo>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetAssociation(
        cluster,
        account,
        user,
        partition,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get association info
     * @param {string} [cluster] Cluster name
     * @param {string} [account] Account name
     * @param {string} [user] User name
     * @param {string} [partition] Partition Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetAssociation_23(
      cluster?: string,
      account?: string,
      user?: string,
      partition?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037AssociationsInfo>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetAssociation_23(
        cluster,
        account,
        user,
        partition,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get association list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetAssociations(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036AssociationsInfo>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetAssociations(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get association list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetAssociations_24(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037AssociationsInfo>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetAssociations_24(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get cluster info
     * @param {string} clusterName Slurm cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetCluster(
      clusterName: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036ClusterInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetCluster(
        clusterName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get cluster info
     * @param {string} clusterName Slurm cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetCluster_25(
      clusterName: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037ClusterInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetCluster_25(
        clusterName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get cluster list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetClusters(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036ClusterInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetClusters(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get cluster list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetClusters_26(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037ClusterInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetClusters_26(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Dump all configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetDbConfig(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036ConfigInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetDbConfig(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Dump all configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetDbConfig_27(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037ConfigInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetDbConfig_27(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
     * @summary Get job info
     * @param {number} jobId Slurm Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetJob(
      jobId: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036JobInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetJob(jobId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
     * @summary Get job info
     * @param {number} jobId Slurm Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetJob_28(
      jobId: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037JobInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetJob_28(jobId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get job list
     * @param {string} [submitTime] Filter by submission time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [startTime] Filter by start time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [endTime] Filter by end time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [account] Comma delimited list of accounts to match
     * @param {string} [association] Comma delimited list of associations to match
     * @param {string} [cluster] Comma delimited list of cluster to match
     * @param {string} [constraints] Comma delimited list of constraints to match
     * @param {string} [cpusMax] Number of CPUs high range
     * @param {string} [cpusMin] Number of CPUs low range
     * @param {boolean} [skipSteps] Report job step information
     * @param {boolean} [disableWaitForResult] Disable waiting for result from slurmdbd
     * @param {string} [exitCode] Exit code of job
     * @param {string} [format] Comma delimited list of formats to match
     * @param {string} [group] Comma delimited list of groups to match
     * @param {string} [jobName] Comma delimited list of job names to match
     * @param {string} [nodesMax] Number of nodes high range
     * @param {string} [nodesMin] Number of nodes low range
     * @param {string} [partition] Comma delimited list of partitions to match
     * @param {string} [qos] Comma delimited list of QOS to match
     * @param {string} [reason] Comma delimited list of job reasons to match
     * @param {string} [reservation] Comma delimited list of reservations to match
     * @param {string} [state] Comma delimited list of states to match
     * @param {string} [step] Comma delimited list of job steps to match
     * @param {string} [node] Comma delimited list of used nodes to match
     * @param {string} [wckey] Comma delimited list of wckeys to match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetJobs(
      submitTime?: string,
      startTime?: string,
      endTime?: string,
      account?: string,
      association?: string,
      cluster?: string,
      constraints?: string,
      cpusMax?: string,
      cpusMin?: string,
      skipSteps?: boolean,
      disableWaitForResult?: boolean,
      exitCode?: string,
      format?: string,
      group?: string,
      jobName?: string,
      nodesMax?: string,
      nodesMin?: string,
      partition?: string,
      qos?: string,
      reason?: string,
      reservation?: string,
      state?: string,
      step?: string,
      node?: string,
      wckey?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036JobInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetJobs(
        submitTime,
        startTime,
        endTime,
        account,
        association,
        cluster,
        constraints,
        cpusMax,
        cpusMin,
        skipSteps,
        disableWaitForResult,
        exitCode,
        format,
        group,
        jobName,
        nodesMax,
        nodesMin,
        partition,
        qos,
        reason,
        reservation,
        state,
        step,
        node,
        wckey,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get job list
     * @param {string} [submitTime] Filter by submission time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [startTime] Filter by start time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [endTime] Filter by end time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [account] Comma delimited list of accounts to match
     * @param {string} [association] Comma delimited list of associations to match
     * @param {string} [cluster] Comma delimited list of cluster to match
     * @param {string} [constraints] Comma delimited list of constraints to match
     * @param {string} [cpusMax] Number of CPUs high range
     * @param {string} [cpusMin] Number of CPUs low range
     * @param {boolean} [skipSteps] Report job step information
     * @param {boolean} [disableWaitForResult] Disable waiting for result from slurmdbd
     * @param {string} [exitCode] Exit code of job
     * @param {string} [format] Comma delimited list of formats to match
     * @param {string} [group] Comma delimited list of groups to match
     * @param {string} [jobName] Comma delimited list of job names to match
     * @param {string} [nodesMax] Number of nodes high range
     * @param {string} [nodesMin] Number of nodes low range
     * @param {string} [partition] Comma delimited list of partitions to match
     * @param {string} [qos] Comma delimited list of QOS to match
     * @param {string} [reason] Comma delimited list of job reasons to match
     * @param {string} [reservation] Comma delimited list of reservations to match
     * @param {string} [state] Comma delimited list of states to match
     * @param {string} [step] Comma delimited list of job steps to match
     * @param {string} [node] Comma delimited list of used nodes to match
     * @param {string} [wckey] Comma delimited list of wckeys to match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetJobs_29(
      submitTime?: string,
      startTime?: string,
      endTime?: string,
      account?: string,
      association?: string,
      cluster?: string,
      constraints?: string,
      cpusMax?: string,
      cpusMin?: string,
      skipSteps?: boolean,
      disableWaitForResult?: boolean,
      exitCode?: string,
      format?: string,
      group?: string,
      jobName?: string,
      nodesMax?: string,
      nodesMin?: string,
      partition?: string,
      qos?: string,
      reason?: string,
      reservation?: string,
      state?: string,
      step?: string,
      node?: string,
      wckey?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037JobInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetJobs_29(
        submitTime,
        startTime,
        endTime,
        account,
        association,
        cluster,
        constraints,
        cpusMax,
        cpusMin,
        skipSteps,
        disableWaitForResult,
        exitCode,
        format,
        group,
        jobName,
        nodesMax,
        nodesMin,
        partition,
        qos,
        reason,
        reservation,
        state,
        step,
        node,
        wckey,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get QOS list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetQos(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036QosInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetQos(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get QOS list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetQos_30(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037QosInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetQos_30(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get QOS info
     * @param {string} qosName Slurm QOS Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetSingleQos(
      qosName: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036QosInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetSingleQos(
        qosName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get QOS info
     * @param {string} qosName Slurm QOS Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetSingleQos_31(
      qosName: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037QosInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetSingleQos_31(
        qosName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get TRES info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetTres(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036TresInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetTres(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get TRES info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetTres_32(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037TresInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetTres_32(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get user info
     * @param {string} userName Slurm User Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetUser(
      userName: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036UserInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetUser(userName, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get user info
     * @param {string} userName Slurm User Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetUser_33(
      userName: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037UserInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetUser_33(
        userName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get user list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetUsers(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036UserInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetUsers(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get user list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetUsers_34(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037UserInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetUsers_34(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get wckey info
     * @param {string} wckey Slurm wckey name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetWckey(
      wckey: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036WckeyInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetWckey(wckey, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get wckey info
     * @param {string} wckey Slurm wckey name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetWckey_35(
      wckey: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037WckeyInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetWckey_35(wckey, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get wckey list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetWckeys(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036WckeyInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetWckeys(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get wckey list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdGetWckeys_36(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037WckeyInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdGetWckeys_36(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Load all configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdSetDbConfig(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036ConfigResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdSetDbConfig(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Load all configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdSetDbConfig_37(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037ConfigResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdSetDbConfig_37(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdUpdateAccount(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036AccountResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdUpdateAccount(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdUpdateAccount_38(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037AccountResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdUpdateAccount_38(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Set TRES info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdUpdateTres(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036ResponseTres>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdUpdateTres(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Set TRES info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdUpdateTres_39(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037ResponseTres>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdUpdateTres_39(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdUpdateUsers(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0036ResponseUserUpdate>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdUpdateUsers(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async slurmdbdUpdateUsers_40(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0037ResponseUserUpdate>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbdUpdateUsers_40(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SlurmApi - factory interface
 * @export
 */
export const SlurmApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SlurmApiFp(configuration);
  return {
    /**
     *
     * @summary cancel or signal job
     * @param {number} jobId Slurm Job ID
     * @param {V0037Signal} [signal] signal to send to job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldCancelJob(jobId: number, signal?: V0037Signal, options?: any): AxiosPromise<void> {
      return localVarFp
        .slurmctldCancelJob(jobId, signal, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary cancel or signal job
     * @param {number} jobId Slurm Job ID
     * @param {V0036Signal} [signal] signal to send to job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldCancelJob_1(jobId: number, signal?: V0036Signal, options?: any): AxiosPromise<void> {
      return localVarFp
        .slurmctldCancelJob_1(jobId, signal, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get diagnostics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldDiag(options?: any): AxiosPromise<V0037Diag> {
      return localVarFp.slurmctldDiag(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get diagnostics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldDiag_2(options?: any): AxiosPromise<V0036Diag> {
      return localVarFp.slurmctldDiag_2(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get job info
     * @param {number} jobId Slurm Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetJob(jobId: number, options?: any): AxiosPromise<V0037JobsResponse> {
      return localVarFp.slurmctldGetJob(jobId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get job info
     * @param {number} jobId Slurm Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetJob_3(jobId: number, options?: any): AxiosPromise<V0036JobsResponse> {
      return localVarFp.slurmctldGetJob_3(jobId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get list of jobs
     * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetJobs(updateTime?: number, options?: any): AxiosPromise<V0037JobsResponse> {
      return localVarFp
        .slurmctldGetJobs(updateTime, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get list of jobs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetJobs_4(options?: any): AxiosPromise<V0036JobsResponse> {
      return localVarFp.slurmctldGetJobs_4(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get node info
     * @param {string} nodeName Slurm Node Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetNode(nodeName: string, options?: any): AxiosPromise<V0037NodesResponse> {
      return localVarFp
        .slurmctldGetNode(nodeName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get node info
     * @param {string} nodeName Slurm Node Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetNode_5(nodeName: string, options?: any): AxiosPromise<V0036NodesResponse> {
      return localVarFp
        .slurmctldGetNode_5(nodeName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get all node info
     * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetNodes(updateTime?: number, options?: any): AxiosPromise<V0037NodesResponse> {
      return localVarFp
        .slurmctldGetNodes(updateTime, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get all node info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetNodes_6(options?: any): AxiosPromise<V0036NodesResponse> {
      return localVarFp.slurmctldGetNodes_6(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get partition info
     * @param {string} partitionName Slurm Partition Name
     * @param {number} [updateTime] Filter if there were no partition changes (not limited to partition in URL endpoint) since update_time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetPartition(
      partitionName: string,
      updateTime?: number,
      options?: any
    ): AxiosPromise<V0037PartitionsResponse> {
      return localVarFp
        .slurmctldGetPartition(partitionName, updateTime, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get partition info
     * @param {string} partitionName Slurm Partition Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetPartition_7(
      partitionName: string,
      options?: any
    ): AxiosPromise<V0036PartitionsResponse> {
      return localVarFp
        .slurmctldGetPartition_7(partitionName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get all partition info
     * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetPartitions(
      updateTime?: number,
      options?: any
    ): AxiosPromise<V0037PartitionsResponse> {
      return localVarFp
        .slurmctldGetPartitions(updateTime, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get all partition info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetPartitions_8(options?: any): AxiosPromise<V0036PartitionsResponse> {
      return localVarFp.slurmctldGetPartitions_8(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get reservation info
     * @param {string} reservationName Slurm Reservation Name
     * @param {number} [updateTime] Filter if no reservation (not limited to reservation in URL) changed since update_time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetReservation(
      reservationName: string,
      updateTime?: number,
      options?: any
    ): AxiosPromise<V0037ReservationsResponse> {
      return localVarFp
        .slurmctldGetReservation(reservationName, updateTime, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary get all reservation info
     * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldGetReservations(
      updateTime?: number,
      options?: any
    ): AxiosPromise<V0037ReservationsResponse> {
      return localVarFp
        .slurmctldGetReservations(updateTime, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary ping test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldPing(options?: any): AxiosPromise<V0037Pings> {
      return localVarFp.slurmctldPing(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary ping test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldPing_9(options?: any): AxiosPromise<V0036Pings> {
      return localVarFp.slurmctldPing_9(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary submit new job
     * @param {V0037JobSubmission} v0037JobSubmission submit new job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldSubmitJob(
      v0037JobSubmission: V0037JobSubmission,
      options?: any
    ): AxiosPromise<V0037JobSubmissionResponse> {
      return localVarFp
        .slurmctldSubmitJob(v0037JobSubmission, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary submit new job
     * @param {V0036JobSubmission} v0036JobSubmission submit new job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldSubmitJob_10(
      v0036JobSubmission: V0036JobSubmission,
      options?: any
    ): AxiosPromise<V0036JobSubmissionResponse> {
      return localVarFp
        .slurmctldSubmitJob_10(v0036JobSubmission, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary update job
     * @param {number} jobId Slurm Job ID
     * @param {V0037JobProperties} v0037JobProperties update job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldUpdateJob(
      jobId: number,
      v0037JobProperties: V0037JobProperties,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .slurmctldUpdateJob(jobId, v0037JobProperties, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary update job
     * @param {number} jobId Slurm Job ID
     * @param {V0036JobProperties} v0036JobProperties update job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmctldUpdateJob_11(
      jobId: number,
      v0036JobProperties: V0036JobProperties,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .slurmctldUpdateJob_11(jobId, v0036JobProperties, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Add clusters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdAddClusters(options?: any): AxiosPromise<Dbv0036ResponseClusterAdd> {
      return localVarFp.slurmdbdAddClusters(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Add clusters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdAddClusters_12(options?: any): AxiosPromise<Dbv0037ResponseClusterAdd> {
      return localVarFp.slurmdbdAddClusters_12(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Add wckeys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdAddWckeys(options?: any): AxiosPromise<Dbv0036ResponseWckeyAdd> {
      return localVarFp.slurmdbdAddWckeys(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Add wckeys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdAddWckeys_13(options?: any): AxiosPromise<Dbv0037ResponseWckeyAdd> {
      return localVarFp.slurmdbdAddWckeys_13(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete account
     * @param {string} accountName Slurm Account Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteAccount(
      accountName: string,
      options?: any
    ): AxiosPromise<Dbv0036ResponseAccountDelete> {
      return localVarFp
        .slurmdbdDeleteAccount(accountName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete account
     * @param {string} accountName Slurm Account Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteAccount_14(
      accountName: string,
      options?: any
    ): AxiosPromise<Dbv0037ResponseAccountDelete> {
      return localVarFp
        .slurmdbdDeleteAccount_14(accountName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete association
     * @param {string} account Account name
     * @param {string} user User name
     * @param {string} [cluster] Cluster name
     * @param {string} [partition] Partition Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteAssociation(
      account: string,
      user: string,
      cluster?: string,
      partition?: string,
      options?: any
    ): AxiosPromise<Dbv0036ResponseAssociationDelete> {
      return localVarFp
        .slurmdbdDeleteAssociation(account, user, cluster, partition, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete association
     * @param {string} account Account name
     * @param {string} user User name
     * @param {string} [cluster] Cluster name
     * @param {string} [partition] Partition Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteAssociation_15(
      account: string,
      user: string,
      cluster?: string,
      partition?: string,
      options?: any
    ): AxiosPromise<Dbv0037ResponseAssociationDelete> {
      return localVarFp
        .slurmdbdDeleteAssociation_15(account, user, cluster, partition, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete cluster
     * @param {string} clusterName Slurm cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteCluster(
      clusterName: string,
      options?: any
    ): AxiosPromise<Dbv0036ResponseClusterDelete> {
      return localVarFp
        .slurmdbdDeleteCluster(clusterName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete cluster
     * @param {string} clusterName Slurm cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteCluster_16(
      clusterName: string,
      options?: any
    ): AxiosPromise<Dbv0037ResponseClusterDelete> {
      return localVarFp
        .slurmdbdDeleteCluster_16(clusterName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete QOS
     * @param {string} qosName Slurm QOS Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteQos(qosName: string, options?: any): AxiosPromise<Dbv0036ResponseQosDelete> {
      return localVarFp
        .slurmdbdDeleteQos(qosName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete QOS
     * @param {string} qosName Slurm QOS Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteQos_17(qosName: string, options?: any): AxiosPromise<Dbv0037ResponseQosDelete> {
      return localVarFp
        .slurmdbdDeleteQos_17(qosName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete user
     * @param {string} userName Slurm User Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteUser(userName: string, options?: any): AxiosPromise<Dbv0036ResponseUserDelete> {
      return localVarFp
        .slurmdbdDeleteUser(userName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete user
     * @param {string} userName Slurm User Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteUser_18(
      userName: string,
      options?: any
    ): AxiosPromise<Dbv0037ResponseUserDelete> {
      return localVarFp
        .slurmdbdDeleteUser_18(userName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete wckey
     * @param {string} wckey Slurm wckey name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteWckey(wckey: string, options?: any): AxiosPromise<Dbv0036ResponseWckeyDelete> {
      return localVarFp
        .slurmdbdDeleteWckey(wckey, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete wckey
     * @param {string} wckey Slurm wckey name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDeleteWckey_19(wckey: string, options?: any): AxiosPromise<Dbv0037ResponseWckeyDelete> {
      return localVarFp
        .slurmdbdDeleteWckey_19(wckey, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get slurmdb diagnostics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDiag(options?: any): AxiosPromise<Dbv0036Diag> {
      return localVarFp.slurmdbdDiag(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get slurmdb diagnostics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdDiag_20(options?: any): AxiosPromise<Dbv0037Diag> {
      return localVarFp.slurmdbdDiag_20(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get account info
     * @param {string} accountName Slurm Account Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetAccount(accountName: string, options?: any): AxiosPromise<Dbv0036AccountInfo> {
      return localVarFp
        .slurmdbdGetAccount(accountName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get account info
     * @param {string} accountName Slurm Account Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetAccount_21(accountName: string, options?: any): AxiosPromise<Dbv0037AccountInfo> {
      return localVarFp
        .slurmdbdGetAccount_21(accountName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get account list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetAccounts(options?: any): AxiosPromise<Dbv0036AccountInfo> {
      return localVarFp.slurmdbdGetAccounts(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get account list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetAccounts_22(options?: any): AxiosPromise<Dbv0037AccountInfo> {
      return localVarFp.slurmdbdGetAccounts_22(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get association info
     * @param {string} [cluster] Cluster name
     * @param {string} [account] Account name
     * @param {string} [user] User name
     * @param {string} [partition] Partition Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetAssociation(
      cluster?: string,
      account?: string,
      user?: string,
      partition?: string,
      options?: any
    ): AxiosPromise<Dbv0036AssociationsInfo> {
      return localVarFp
        .slurmdbdGetAssociation(cluster, account, user, partition, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get association info
     * @param {string} [cluster] Cluster name
     * @param {string} [account] Account name
     * @param {string} [user] User name
     * @param {string} [partition] Partition Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetAssociation_23(
      cluster?: string,
      account?: string,
      user?: string,
      partition?: string,
      options?: any
    ): AxiosPromise<Dbv0037AssociationsInfo> {
      return localVarFp
        .slurmdbdGetAssociation_23(cluster, account, user, partition, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get association list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetAssociations(options?: any): AxiosPromise<Dbv0036AssociationsInfo> {
      return localVarFp.slurmdbdGetAssociations(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get association list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetAssociations_24(options?: any): AxiosPromise<Dbv0037AssociationsInfo> {
      return localVarFp
        .slurmdbdGetAssociations_24(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get cluster info
     * @param {string} clusterName Slurm cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetCluster(clusterName: string, options?: any): AxiosPromise<Dbv0036ClusterInfo> {
      return localVarFp
        .slurmdbdGetCluster(clusterName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get cluster info
     * @param {string} clusterName Slurm cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetCluster_25(clusterName: string, options?: any): AxiosPromise<Dbv0037ClusterInfo> {
      return localVarFp
        .slurmdbdGetCluster_25(clusterName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get cluster list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetClusters(options?: any): AxiosPromise<Dbv0036ClusterInfo> {
      return localVarFp.slurmdbdGetClusters(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get cluster list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetClusters_26(options?: any): AxiosPromise<Dbv0037ClusterInfo> {
      return localVarFp.slurmdbdGetClusters_26(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Dump all configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetDbConfig(options?: any): AxiosPromise<Dbv0036ConfigInfo> {
      return localVarFp.slurmdbdGetDbConfig(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Dump all configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetDbConfig_27(options?: any): AxiosPromise<Dbv0037ConfigInfo> {
      return localVarFp.slurmdbdGetDbConfig_27(options).then(request => request(axios, basePath));
    },
    /**
     * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
     * @summary Get job info
     * @param {number} jobId Slurm Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetJob(jobId: number, options?: any): AxiosPromise<Dbv0036JobInfo> {
      return localVarFp.slurmdbdGetJob(jobId, options).then(request => request(axios, basePath));
    },
    /**
     * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
     * @summary Get job info
     * @param {number} jobId Slurm Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetJob_28(jobId: number, options?: any): AxiosPromise<Dbv0037JobInfo> {
      return localVarFp.slurmdbdGetJob_28(jobId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get job list
     * @param {string} [submitTime] Filter by submission time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [startTime] Filter by start time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [endTime] Filter by end time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [account] Comma delimited list of accounts to match
     * @param {string} [association] Comma delimited list of associations to match
     * @param {string} [cluster] Comma delimited list of cluster to match
     * @param {string} [constraints] Comma delimited list of constraints to match
     * @param {string} [cpusMax] Number of CPUs high range
     * @param {string} [cpusMin] Number of CPUs low range
     * @param {boolean} [skipSteps] Report job step information
     * @param {boolean} [disableWaitForResult] Disable waiting for result from slurmdbd
     * @param {string} [exitCode] Exit code of job
     * @param {string} [format] Comma delimited list of formats to match
     * @param {string} [group] Comma delimited list of groups to match
     * @param {string} [jobName] Comma delimited list of job names to match
     * @param {string} [nodesMax] Number of nodes high range
     * @param {string} [nodesMin] Number of nodes low range
     * @param {string} [partition] Comma delimited list of partitions to match
     * @param {string} [qos] Comma delimited list of QOS to match
     * @param {string} [reason] Comma delimited list of job reasons to match
     * @param {string} [reservation] Comma delimited list of reservations to match
     * @param {string} [state] Comma delimited list of states to match
     * @param {string} [step] Comma delimited list of job steps to match
     * @param {string} [node] Comma delimited list of used nodes to match
     * @param {string} [wckey] Comma delimited list of wckeys to match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetJobs(
      submitTime?: string,
      startTime?: string,
      endTime?: string,
      account?: string,
      association?: string,
      cluster?: string,
      constraints?: string,
      cpusMax?: string,
      cpusMin?: string,
      skipSteps?: boolean,
      disableWaitForResult?: boolean,
      exitCode?: string,
      format?: string,
      group?: string,
      jobName?: string,
      nodesMax?: string,
      nodesMin?: string,
      partition?: string,
      qos?: string,
      reason?: string,
      reservation?: string,
      state?: string,
      step?: string,
      node?: string,
      wckey?: string,
      options?: any
    ): AxiosPromise<Dbv0036JobInfo> {
      return localVarFp
        .slurmdbdGetJobs(
          submitTime,
          startTime,
          endTime,
          account,
          association,
          cluster,
          constraints,
          cpusMax,
          cpusMin,
          skipSteps,
          disableWaitForResult,
          exitCode,
          format,
          group,
          jobName,
          nodesMax,
          nodesMin,
          partition,
          qos,
          reason,
          reservation,
          state,
          step,
          node,
          wckey,
          options
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get job list
     * @param {string} [submitTime] Filter by submission time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [startTime] Filter by start time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [endTime] Filter by end time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [account] Comma delimited list of accounts to match
     * @param {string} [association] Comma delimited list of associations to match
     * @param {string} [cluster] Comma delimited list of cluster to match
     * @param {string} [constraints] Comma delimited list of constraints to match
     * @param {string} [cpusMax] Number of CPUs high range
     * @param {string} [cpusMin] Number of CPUs low range
     * @param {boolean} [skipSteps] Report job step information
     * @param {boolean} [disableWaitForResult] Disable waiting for result from slurmdbd
     * @param {string} [exitCode] Exit code of job
     * @param {string} [format] Comma delimited list of formats to match
     * @param {string} [group] Comma delimited list of groups to match
     * @param {string} [jobName] Comma delimited list of job names to match
     * @param {string} [nodesMax] Number of nodes high range
     * @param {string} [nodesMin] Number of nodes low range
     * @param {string} [partition] Comma delimited list of partitions to match
     * @param {string} [qos] Comma delimited list of QOS to match
     * @param {string} [reason] Comma delimited list of job reasons to match
     * @param {string} [reservation] Comma delimited list of reservations to match
     * @param {string} [state] Comma delimited list of states to match
     * @param {string} [step] Comma delimited list of job steps to match
     * @param {string} [node] Comma delimited list of used nodes to match
     * @param {string} [wckey] Comma delimited list of wckeys to match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetJobs_29(
      submitTime?: string,
      startTime?: string,
      endTime?: string,
      account?: string,
      association?: string,
      cluster?: string,
      constraints?: string,
      cpusMax?: string,
      cpusMin?: string,
      skipSteps?: boolean,
      disableWaitForResult?: boolean,
      exitCode?: string,
      format?: string,
      group?: string,
      jobName?: string,
      nodesMax?: string,
      nodesMin?: string,
      partition?: string,
      qos?: string,
      reason?: string,
      reservation?: string,
      state?: string,
      step?: string,
      node?: string,
      wckey?: string,
      options?: any
    ): AxiosPromise<Dbv0037JobInfo> {
      return localVarFp
        .slurmdbdGetJobs_29(
          submitTime,
          startTime,
          endTime,
          account,
          association,
          cluster,
          constraints,
          cpusMax,
          cpusMin,
          skipSteps,
          disableWaitForResult,
          exitCode,
          format,
          group,
          jobName,
          nodesMax,
          nodesMin,
          partition,
          qos,
          reason,
          reservation,
          state,
          step,
          node,
          wckey,
          options
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get QOS list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetQos(options?: any): AxiosPromise<Dbv0036QosInfo> {
      return localVarFp.slurmdbdGetQos(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get QOS list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetQos_30(options?: any): AxiosPromise<Dbv0037QosInfo> {
      return localVarFp.slurmdbdGetQos_30(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get QOS info
     * @param {string} qosName Slurm QOS Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetSingleQos(qosName: string, options?: any): AxiosPromise<Dbv0036QosInfo> {
      return localVarFp
        .slurmdbdGetSingleQos(qosName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get QOS info
     * @param {string} qosName Slurm QOS Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetSingleQos_31(qosName: string, options?: any): AxiosPromise<Dbv0037QosInfo> {
      return localVarFp
        .slurmdbdGetSingleQos_31(qosName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get TRES info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetTres(options?: any): AxiosPromise<Dbv0036TresInfo> {
      return localVarFp.slurmdbdGetTres(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get TRES info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetTres_32(options?: any): AxiosPromise<Dbv0037TresInfo> {
      return localVarFp.slurmdbdGetTres_32(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get user info
     * @param {string} userName Slurm User Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetUser(userName: string, options?: any): AxiosPromise<Dbv0036UserInfo> {
      return localVarFp
        .slurmdbdGetUser(userName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get user info
     * @param {string} userName Slurm User Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetUser_33(userName: string, options?: any): AxiosPromise<Dbv0037UserInfo> {
      return localVarFp
        .slurmdbdGetUser_33(userName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get user list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetUsers(options?: any): AxiosPromise<Dbv0036UserInfo> {
      return localVarFp.slurmdbdGetUsers(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get user list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetUsers_34(options?: any): AxiosPromise<Dbv0037UserInfo> {
      return localVarFp.slurmdbdGetUsers_34(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get wckey info
     * @param {string} wckey Slurm wckey name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetWckey(wckey: string, options?: any): AxiosPromise<Dbv0036WckeyInfo> {
      return localVarFp.slurmdbdGetWckey(wckey, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get wckey info
     * @param {string} wckey Slurm wckey name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetWckey_35(wckey: string, options?: any): AxiosPromise<Dbv0037WckeyInfo> {
      return localVarFp
        .slurmdbdGetWckey_35(wckey, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get wckey list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetWckeys(options?: any): AxiosPromise<Dbv0036WckeyInfo> {
      return localVarFp.slurmdbdGetWckeys(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get wckey list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdGetWckeys_36(options?: any): AxiosPromise<Dbv0037WckeyInfo> {
      return localVarFp.slurmdbdGetWckeys_36(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Load all configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdSetDbConfig(options?: any): AxiosPromise<Dbv0036ConfigResponse> {
      return localVarFp.slurmdbdSetDbConfig(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Load all configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdSetDbConfig_37(options?: any): AxiosPromise<Dbv0037ConfigResponse> {
      return localVarFp.slurmdbdSetDbConfig_37(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Update accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdUpdateAccount(options?: any): AxiosPromise<Dbv0036AccountResponse> {
      return localVarFp.slurmdbdUpdateAccount(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Update accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdUpdateAccount_38(options?: any): AxiosPromise<Dbv0037AccountResponse> {
      return localVarFp.slurmdbdUpdateAccount_38(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Set TRES info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdUpdateTres(options?: any): AxiosPromise<Dbv0036ResponseTres> {
      return localVarFp.slurmdbdUpdateTres(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Set TRES info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdUpdateTres_39(options?: any): AxiosPromise<Dbv0037ResponseTres> {
      return localVarFp.slurmdbdUpdateTres_39(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Update user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdUpdateUsers(options?: any): AxiosPromise<Dbv0036ResponseUserUpdate> {
      return localVarFp.slurmdbdUpdateUsers(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Update user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    slurmdbdUpdateUsers_40(options?: any): AxiosPromise<Dbv0037ResponseUserUpdate> {
      return localVarFp.slurmdbdUpdateUsers_40(options).then(request => request(axios, basePath));
    },
  };
};

/**
 * SlurmApi - object-oriented interface
 * @export
 * @class SlurmApi
 * @extends {BaseAPI}
 */
export class SlurmApi extends BaseAPI {
  /**
   *
   * @summary cancel or signal job
   * @param {number} jobId Slurm Job ID
   * @param {V0037Signal} [signal] signal to send to job
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldCancelJob(jobId: number, signal?: V0037Signal, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldCancelJob(jobId, signal, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary cancel or signal job
   * @param {number} jobId Slurm Job ID
   * @param {V0036Signal} [signal] signal to send to job
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldCancelJob_1(jobId: number, signal?: V0036Signal, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldCancelJob_1(jobId, signal, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get diagnostics
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldDiag(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldDiag(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get diagnostics
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldDiag_2(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldDiag_2(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get job info
   * @param {number} jobId Slurm Job ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldGetJob(jobId: number, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldGetJob(jobId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get job info
   * @param {number} jobId Slurm Job ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldGetJob_3(jobId: number, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldGetJob_3(jobId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get list of jobs
   * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldGetJobs(updateTime?: number, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldGetJobs(updateTime, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get list of jobs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldGetJobs_4(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldGetJobs_4(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get node info
   * @param {string} nodeName Slurm Node Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldGetNode(nodeName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldGetNode(nodeName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get node info
   * @param {string} nodeName Slurm Node Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldGetNode_5(nodeName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldGetNode_5(nodeName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get all node info
   * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldGetNodes(updateTime?: number, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldGetNodes(updateTime, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get all node info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldGetNodes_6(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldGetNodes_6(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get partition info
   * @param {string} partitionName Slurm Partition Name
   * @param {number} [updateTime] Filter if there were no partition changes (not limited to partition in URL endpoint) since update_time.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldGetPartition(
    partitionName: string,
    updateTime?: number,
    options?: AxiosRequestConfig
  ) {
    return SlurmApiFp(this.configuration)
      .slurmctldGetPartition(partitionName, updateTime, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get partition info
   * @param {string} partitionName Slurm Partition Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldGetPartition_7(partitionName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldGetPartition_7(partitionName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get all partition info
   * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldGetPartitions(updateTime?: number, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldGetPartitions(updateTime, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get all partition info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldGetPartitions_8(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldGetPartitions_8(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get reservation info
   * @param {string} reservationName Slurm Reservation Name
   * @param {number} [updateTime] Filter if no reservation (not limited to reservation in URL) changed since update_time.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldGetReservation(
    reservationName: string,
    updateTime?: number,
    options?: AxiosRequestConfig
  ) {
    return SlurmApiFp(this.configuration)
      .slurmctldGetReservation(reservationName, updateTime, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get all reservation info
   * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldGetReservations(updateTime?: number, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldGetReservations(updateTime, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary ping test
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldPing(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldPing(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary ping test
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldPing_9(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldPing_9(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary submit new job
   * @param {V0037JobSubmission} v0037JobSubmission submit new job
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldSubmitJob(v0037JobSubmission: V0037JobSubmission, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmctldSubmitJob(v0037JobSubmission, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary submit new job
   * @param {V0036JobSubmission} v0036JobSubmission submit new job
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldSubmitJob_10(
    v0036JobSubmission: V0036JobSubmission,
    options?: AxiosRequestConfig
  ) {
    return SlurmApiFp(this.configuration)
      .slurmctldSubmitJob_10(v0036JobSubmission, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary update job
   * @param {number} jobId Slurm Job ID
   * @param {V0037JobProperties} v0037JobProperties update job
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldUpdateJob(
    jobId: number,
    v0037JobProperties: V0037JobProperties,
    options?: AxiosRequestConfig
  ) {
    return SlurmApiFp(this.configuration)
      .slurmctldUpdateJob(jobId, v0037JobProperties, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary update job
   * @param {number} jobId Slurm Job ID
   * @param {V0036JobProperties} v0036JobProperties update job
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmctldUpdateJob_11(
    jobId: number,
    v0036JobProperties: V0036JobProperties,
    options?: AxiosRequestConfig
  ) {
    return SlurmApiFp(this.configuration)
      .slurmctldUpdateJob_11(jobId, v0036JobProperties, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add clusters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdAddClusters(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdAddClusters(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add clusters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdAddClusters_12(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdAddClusters_12(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add wckeys
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdAddWckeys(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdAddWckeys(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add wckeys
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdAddWckeys_13(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdAddWckeys_13(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete account
   * @param {string} accountName Slurm Account Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdDeleteAccount(accountName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdDeleteAccount(accountName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete account
   * @param {string} accountName Slurm Account Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdDeleteAccount_14(accountName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdDeleteAccount_14(accountName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete association
   * @param {string} account Account name
   * @param {string} user User name
   * @param {string} [cluster] Cluster name
   * @param {string} [partition] Partition Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdDeleteAssociation(
    account: string,
    user: string,
    cluster?: string,
    partition?: string,
    options?: AxiosRequestConfig
  ) {
    return SlurmApiFp(this.configuration)
      .slurmdbdDeleteAssociation(account, user, cluster, partition, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete association
   * @param {string} account Account name
   * @param {string} user User name
   * @param {string} [cluster] Cluster name
   * @param {string} [partition] Partition Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdDeleteAssociation_15(
    account: string,
    user: string,
    cluster?: string,
    partition?: string,
    options?: AxiosRequestConfig
  ) {
    return SlurmApiFp(this.configuration)
      .slurmdbdDeleteAssociation_15(account, user, cluster, partition, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete cluster
   * @param {string} clusterName Slurm cluster name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdDeleteCluster(clusterName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdDeleteCluster(clusterName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete cluster
   * @param {string} clusterName Slurm cluster name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdDeleteCluster_16(clusterName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdDeleteCluster_16(clusterName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete QOS
   * @param {string} qosName Slurm QOS Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdDeleteQos(qosName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdDeleteQos(qosName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete QOS
   * @param {string} qosName Slurm QOS Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdDeleteQos_17(qosName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdDeleteQos_17(qosName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete user
   * @param {string} userName Slurm User Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdDeleteUser(userName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdDeleteUser(userName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete user
   * @param {string} userName Slurm User Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdDeleteUser_18(userName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdDeleteUser_18(userName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete wckey
   * @param {string} wckey Slurm wckey name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdDeleteWckey(wckey: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdDeleteWckey(wckey, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete wckey
   * @param {string} wckey Slurm wckey name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdDeleteWckey_19(wckey: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdDeleteWckey_19(wckey, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get slurmdb diagnostics
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdDiag(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdDiag(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get slurmdb diagnostics
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdDiag_20(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdDiag_20(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get account info
   * @param {string} accountName Slurm Account Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetAccount(accountName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetAccount(accountName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get account info
   * @param {string} accountName Slurm Account Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetAccount_21(accountName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetAccount_21(accountName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get account list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetAccounts(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetAccounts(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get account list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetAccounts_22(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetAccounts_22(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get association info
   * @param {string} [cluster] Cluster name
   * @param {string} [account] Account name
   * @param {string} [user] User name
   * @param {string} [partition] Partition Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetAssociation(
    cluster?: string,
    account?: string,
    user?: string,
    partition?: string,
    options?: AxiosRequestConfig
  ) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetAssociation(cluster, account, user, partition, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get association info
   * @param {string} [cluster] Cluster name
   * @param {string} [account] Account name
   * @param {string} [user] User name
   * @param {string} [partition] Partition Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetAssociation_23(
    cluster?: string,
    account?: string,
    user?: string,
    partition?: string,
    options?: AxiosRequestConfig
  ) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetAssociation_23(cluster, account, user, partition, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get association list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetAssociations(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetAssociations(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get association list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetAssociations_24(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetAssociations_24(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get cluster info
   * @param {string} clusterName Slurm cluster name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetCluster(clusterName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetCluster(clusterName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get cluster info
   * @param {string} clusterName Slurm cluster name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetCluster_25(clusterName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetCluster_25(clusterName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get cluster list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetClusters(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetClusters(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get cluster list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetClusters_26(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetClusters_26(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Dump all configuration information
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetDbConfig(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetDbConfig(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Dump all configuration information
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetDbConfig_27(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetDbConfig_27(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
   * @summary Get job info
   * @param {number} jobId Slurm Job ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetJob(jobId: number, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetJob(jobId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
   * @summary Get job info
   * @param {number} jobId Slurm Job ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetJob_28(jobId: number, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetJob_28(jobId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get job list
   * @param {string} [submitTime] Filter by submission time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
   * @param {string} [startTime] Filter by start time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
   * @param {string} [endTime] Filter by end time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
   * @param {string} [account] Comma delimited list of accounts to match
   * @param {string} [association] Comma delimited list of associations to match
   * @param {string} [cluster] Comma delimited list of cluster to match
   * @param {string} [constraints] Comma delimited list of constraints to match
   * @param {string} [cpusMax] Number of CPUs high range
   * @param {string} [cpusMin] Number of CPUs low range
   * @param {boolean} [skipSteps] Report job step information
   * @param {boolean} [disableWaitForResult] Disable waiting for result from slurmdbd
   * @param {string} [exitCode] Exit code of job
   * @param {string} [format] Comma delimited list of formats to match
   * @param {string} [group] Comma delimited list of groups to match
   * @param {string} [jobName] Comma delimited list of job names to match
   * @param {string} [nodesMax] Number of nodes high range
   * @param {string} [nodesMin] Number of nodes low range
   * @param {string} [partition] Comma delimited list of partitions to match
   * @param {string} [qos] Comma delimited list of QOS to match
   * @param {string} [reason] Comma delimited list of job reasons to match
   * @param {string} [reservation] Comma delimited list of reservations to match
   * @param {string} [state] Comma delimited list of states to match
   * @param {string} [step] Comma delimited list of job steps to match
   * @param {string} [node] Comma delimited list of used nodes to match
   * @param {string} [wckey] Comma delimited list of wckeys to match
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetJobs(
    submitTime?: string,
    startTime?: string,
    endTime?: string,
    account?: string,
    association?: string,
    cluster?: string,
    constraints?: string,
    cpusMax?: string,
    cpusMin?: string,
    skipSteps?: boolean,
    disableWaitForResult?: boolean,
    exitCode?: string,
    format?: string,
    group?: string,
    jobName?: string,
    nodesMax?: string,
    nodesMin?: string,
    partition?: string,
    qos?: string,
    reason?: string,
    reservation?: string,
    state?: string,
    step?: string,
    node?: string,
    wckey?: string,
    options?: AxiosRequestConfig
  ) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetJobs(
        submitTime,
        startTime,
        endTime,
        account,
        association,
        cluster,
        constraints,
        cpusMax,
        cpusMin,
        skipSteps,
        disableWaitForResult,
        exitCode,
        format,
        group,
        jobName,
        nodesMax,
        nodesMin,
        partition,
        qos,
        reason,
        reservation,
        state,
        step,
        node,
        wckey,
        options
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get job list
   * @param {string} [submitTime] Filter by submission time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
   * @param {string} [startTime] Filter by start time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
   * @param {string} [endTime] Filter by end time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
   * @param {string} [account] Comma delimited list of accounts to match
   * @param {string} [association] Comma delimited list of associations to match
   * @param {string} [cluster] Comma delimited list of cluster to match
   * @param {string} [constraints] Comma delimited list of constraints to match
   * @param {string} [cpusMax] Number of CPUs high range
   * @param {string} [cpusMin] Number of CPUs low range
   * @param {boolean} [skipSteps] Report job step information
   * @param {boolean} [disableWaitForResult] Disable waiting for result from slurmdbd
   * @param {string} [exitCode] Exit code of job
   * @param {string} [format] Comma delimited list of formats to match
   * @param {string} [group] Comma delimited list of groups to match
   * @param {string} [jobName] Comma delimited list of job names to match
   * @param {string} [nodesMax] Number of nodes high range
   * @param {string} [nodesMin] Number of nodes low range
   * @param {string} [partition] Comma delimited list of partitions to match
   * @param {string} [qos] Comma delimited list of QOS to match
   * @param {string} [reason] Comma delimited list of job reasons to match
   * @param {string} [reservation] Comma delimited list of reservations to match
   * @param {string} [state] Comma delimited list of states to match
   * @param {string} [step] Comma delimited list of job steps to match
   * @param {string} [node] Comma delimited list of used nodes to match
   * @param {string} [wckey] Comma delimited list of wckeys to match
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetJobs_29(
    submitTime?: string,
    startTime?: string,
    endTime?: string,
    account?: string,
    association?: string,
    cluster?: string,
    constraints?: string,
    cpusMax?: string,
    cpusMin?: string,
    skipSteps?: boolean,
    disableWaitForResult?: boolean,
    exitCode?: string,
    format?: string,
    group?: string,
    jobName?: string,
    nodesMax?: string,
    nodesMin?: string,
    partition?: string,
    qos?: string,
    reason?: string,
    reservation?: string,
    state?: string,
    step?: string,
    node?: string,
    wckey?: string,
    options?: AxiosRequestConfig
  ) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetJobs_29(
        submitTime,
        startTime,
        endTime,
        account,
        association,
        cluster,
        constraints,
        cpusMax,
        cpusMin,
        skipSteps,
        disableWaitForResult,
        exitCode,
        format,
        group,
        jobName,
        nodesMax,
        nodesMin,
        partition,
        qos,
        reason,
        reservation,
        state,
        step,
        node,
        wckey,
        options
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get QOS list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetQos(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetQos(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get QOS list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetQos_30(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetQos_30(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get QOS info
   * @param {string} qosName Slurm QOS Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetSingleQos(qosName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetSingleQos(qosName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get QOS info
   * @param {string} qosName Slurm QOS Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetSingleQos_31(qosName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetSingleQos_31(qosName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get TRES info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetTres(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetTres(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get TRES info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetTres_32(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetTres_32(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user info
   * @param {string} userName Slurm User Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetUser(userName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetUser(userName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user info
   * @param {string} userName Slurm User Name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetUser_33(userName: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetUser_33(userName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetUsers(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetUsers(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetUsers_34(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetUsers_34(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get wckey info
   * @param {string} wckey Slurm wckey name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetWckey(wckey: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetWckey(wckey, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get wckey info
   * @param {string} wckey Slurm wckey name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetWckey_35(wckey: string, options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetWckey_35(wckey, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get wckey list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetWckeys(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetWckeys(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get wckey list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdGetWckeys_36(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdGetWckeys_36(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Load all configuration information
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdSetDbConfig(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdSetDbConfig(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Load all configuration information
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdSetDbConfig_37(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdSetDbConfig_37(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update accounts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdUpdateAccount(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdUpdateAccount(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update accounts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdUpdateAccount_38(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdUpdateAccount_38(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Set TRES info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdUpdateTres(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdUpdateTres(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Set TRES info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdUpdateTres_39(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdUpdateTres_39(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdUpdateUsers(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdUpdateUsers(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SlurmApi
   */
  public slurmdbdUpdateUsers_40(options?: AxiosRequestConfig) {
    return SlurmApiFp(this.configuration)
      .slurmdbdUpdateUsers_40(options)
      .then(request => request(this.axios, this.basePath));
  }
}
